{"files":[{"path":["/","home","md","language","mdcode","src","main.rs"],"content":"/*\nThis file implements \"mdcode\", a simple code management tool built on top of Git.\nIt provides a command-line interface with commands for creating new repositories,\nupdating repositories (staging changes and committing), displaying repository information,\ndiffing repository versions, and integrating with GitHub (creating a repo and pushing changes).\n\nKey features and structure:\n- Uses Clap for parsing command-line arguments.\n- Leverages git2 for Git repository operations (initial commit, diffing, etc.).\n- Scans directories for source files using WalkDir while filtering out build artifact directories\n  (\"target\", \"bin\", \"obj\", \"venv\", \".venv\", \"env\") that are commonly generated in various build and virtual environment setups.\n- Provides utility functions for generating a .gitignore file, detecting file types, and checking out Git trees.\n- Uses colored logging to provide clear output to the user.\n- Integrates with GitHub using octocrab for API calls.\n*/\n\nuse chrono::{LocalResult, TimeZone, Utc};\nuse clap::{ArgAction, Parser, Subcommand};\nuse git2::{Delta, DiffOptions, ErrorCode, ObjectType, Repository, Signature, Sort};\nuse semver::Version as SemverVersion;\nuse std::env;\nuse std::error::Error;\nuse std::fs;\nuse std::fs::File;\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\nuse tokio::runtime::Runtime;\n// walkdir remains for other areas; ignore's walker handles file scanning honoring .gitignore\n// use walkdir::WalkDir;\nuse ignore::{gitignore::GitignoreBuilder, WalkBuilder as IgnoreWalkBuilder};\n\n// Define our uniform color constants.\nconst BLUE: &str = \"\\x1b[94m\"; // Light blue\nconst GREEN: &str = \"\\x1b[32m\"; // Green\nconst RED: &str = \"\\x1b[31m\"; // Red\nconst YELLOW: &str = \"\\x1b[93m\"; // Light yellow\nconst RESET: &str = \"\\x1b[0m\";\n\n#[derive(Clone, Copy)]\nenum RepoVisibility {\n    Public,\n    Private,\n    Internal,\n}\n\n#[derive(Parser)]\n#[command(\n    name = \"mdcode\",\n    version,\n    about = \"Martin's simple code management tool using Git.\",\n    arg_required_else_help = true,\n    after_help = \"\\\nDiff Modes:\n  mdcode diff <directory>\n    => Compare current working directory vs most recent commit.\n  mdcode diff <directory> <n>\n    => Compare current working directory vs commit selected by n (0 is most recent, 1 for next, etc.).\n  mdcode diff <directory> <n> <m>\n    => Compare commit selected by n (before) vs commit selected by m (after).\n  mdcode diff <directory> H <n>\n    => Compare GitHub HEAD (before) vs local commit selected by n (after).\n  mdcode diff <directory> L\n    => Compare GitHub HEAD (before) vs current working directory (after).\",\n    help_template = \"\\\n{bin} {version}\n{about}\n\nUSAGE:\n    {usage}\n\nCOMMANDS:\n{subcommands}\n\nOPTIONS:\n{options}\n\"\n)]\nstruct Cli {\n    /// Command to run: new, update, info, diff, gh_create, gh_push, gh_fetch, or gh_sync (short aliases shown)\n    #[command(subcommand)]\n    command: Commands,\n\n    /// Perform a dry run (no changes will be made)\n    #[arg(long)]\n    dry_run: bool,\n\n    /// Maximum file size to auto-stage (in MB). Use to include large assets per-invocation.\n    /// Default: 50 MB.\n    #[arg(long = \"max-file-mb\", default_value_t = 50)]\n    max_file_mb: u64,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    #[command(\n        visible_alias = \"n\",\n        about = \"Create a new repository with initial commit\"\n    )]\n    New {\n        /// Directory in which to create the repository\n        directory: String,\n    },\n    #[command(\n        visible_alias = \"u\",\n        about = \"Update an existing repository (stage changes and commit)\"\n    )]\n    Update {\n        /// Directory of the repository to update\n        directory: String,\n    },\n    #[command(\n        visible_alias = \"i\",\n        about = \"Display repository info (latest 20 commits)\"\n    )]\n    Info {\n        /// Directory of the repository to inspect\n        directory: String,\n    },\n    #[command(\n        visible_alias = \"d\",\n        about = \"Diff versions\",\n        long_about = \"Diff versions.\nModes:\n  mdcode diff <directory>\n    => Compare current working directory vs most recent commit.\n  mdcode diff <directory> <n>\n    => Compare current working directory vs commit selected by n (0 is most recent, 1 for next, etc.).\n  mdcode diff <directory> <n> <m>\n    => Compare commit selected by n (before) vs commit selected by m (after).\n  mdcode diff <directory> H <n>\n    => Compare GitHub HEAD (before) vs local commit selected by n (after).\n  mdcode diff <directory> L\n    => Compare GitHub HEAD (before) vs current working directory (after).\"\n    )]\n    Diff {\n        /// Directory of the repository to diff\n        directory: String,\n        /// Optional version numbers (0 is most recent; 1, 2, ... select older commits)\n        #[arg(num_args = 0..=2)]\n        versions: Vec<String>,\n    },\n    #[command(\n        name = \"gh_create\",\n        visible_alias = \"g\",\n        about = \"Create a GitHub repository from the local repository, add it as remote, and push current state\"\n    )]\n    GhCreate {\n        /// Directory of the local repository (e.g. '.' for current directory)\n        directory: String,\n        /// Optional description for the GitHub repository\n        #[arg(short, long)]\n        description: Option<String>,\n        /// Create the repository as public visibility\n        #[arg(long, action = ArgAction::SetTrue)]\n        public: bool,\n        /// Create the repository as private visibility (default)\n        #[arg(long, action = ArgAction::SetTrue)]\n        private: bool,\n        /// Create the repository as internal visibility (orgs only)\n        #[arg(long, action = ArgAction::SetTrue)]\n        internal: bool,\n    },\n    #[command(\n        name = \"gh_push\",\n        visible_alias = \"p\",\n        about = \"Push changes to the GitHub remote\"\n    )]\n    GhPush {\n        /// Directory of the local repository\n        directory: String,\n        /// Name of the remote to push to (default: origin)\n        #[arg(short, long, default_value = \"origin\")]\n        remote: String,\n    },\n    #[command(\n        name = \"gh_fetch\",\n        visible_alias = \"gf\",\n        about = \"Fetch changes from the GitHub remote and list them\"\n    )]\n    GhFetch {\n        /// Directory of the local repository\n        directory: String,\n        /// Name of the remote to fetch from (default: origin)\n        #[arg(short, long, default_value = \"origin\")]\n        remote: String,\n    },\n    #[command(\n        name = \"gh_sync\",\n        visible_alias = \"gs\",\n        about = \"Synchronize the local repository with the GitHub remote\"\n    )]\n    GhSync {\n        /// Directory of the local repository\n        directory: String,\n        /// Name of the remote to sync with (default: origin)\n        #[arg(short, long, default_value = \"origin\")]\n        remote: String,\n    },\n    #[command(\n        name = \"tag\",\n        visible_alias = \"t\",\n        about = \"Create an annotated git tag for the current HEAD\"\n    )]\n    Tag {\n        /// Directory of the local repository (e.g. '.' for current directory)\n        directory: String,\n        /// Optional explicit version (semver). If not provided, read Cargo.toml or prompt.\n        #[arg(short, long)]\n        version: Option<String>,\n        /// Optional tag message. Defaults to 'Release v<version>'.\n        #[arg(short, long)]\n        message: Option<String>,\n        /// Do not push the created tag to the remote (pushes by default).\n        #[arg(long = \"no-push\", action = ArgAction::SetTrue)]\n        no_push: bool,\n        /// Remote name to push to (used with --push). Defaults to 'origin'.\n        #[arg(long, default_value = \"origin\")]\n        remote: String,\n        /// Overwrite an existing tag of the same name.\n        #[arg(long, action = ArgAction::SetTrue)]\n        force: bool,\n        /// Allow tagging when the working tree has uncommitted changes.\n        #[arg(long, action = ArgAction::SetTrue)]\n        allow_dirty: bool,\n    },\n}\n\nfn run() -> Result<(), Box<dyn Error>> {\n    let cli = Cli::parse();\n\n    match &cli.command {\n        Commands::New { directory } => {\n            log::info!(\"Creating new repository in '{}'\", directory);\n            new_repository(directory, cli.dry_run, cli.max_file_mb)?;\n        }\n        Commands::Update { directory } => {\n            log::info!(\"Updating repository in '{}'\", directory);\n            // In interactive use, pass None to prompt the user.\n            update_repository(directory, cli.dry_run, None, cli.max_file_mb)?;\n        }\n        Commands::Info { directory } => {\n            log::info!(\"Displaying repository info for '{}'\", directory);\n            info_repository(directory)?;\n        }\n        Commands::Diff {\n            directory,\n            versions,\n        } => {\n            log::info!(\n                \"Diffing repository '{}' with versions {:?}\",\n                directory,\n                versions\n            );\n            diff_command(directory, versions, cli.dry_run)?;\n        }\n        Commands::GhCreate {\n            directory,\n            description,\n            public,\n            private,\n            internal,\n        } => {\n            log::info!(\n                \"Creating GitHub repository from local directory '{}'\",\n                directory\n            );\n            // Deduce repository name from the provided directory.\n            let repo_name = {\n                let path = Path::new(directory);\n                // If directory is \".\", use current dir.\n                let actual = if path == Path::new(\".\") {\n                    env::current_dir()?\n                } else {\n                    path.to_path_buf()\n                };\n                actual\n                    .file_name()\n                    .ok_or(\"Could not determine repository name from directory\")?\n                    .to_string_lossy()\n                    .to_string()\n            };\n            // Determine visibility; default to private if unspecified.\n            let mut selected = None;\n            if *public {\n                selected = Some(RepoVisibility::Public);\n            }\n            if *private {\n                selected = Some(RepoVisibility::Private);\n            }\n            if *internal {\n                selected = Some(RepoVisibility::Internal);\n            }\n            // If multiple flags were provided, return an error.\n            let count = (*public as u8) + (*private as u8) + (*internal as u8);\n            if count > 1 {\n                return Err(\"Provide only one of --public/--private/--internal\".into());\n            }\n            let visibility = selected.unwrap_or(RepoVisibility::Private);\n\n            if let Some(gh_cmd) = gh_cli_path() {\n                log::info!(\"Detected GitHub CLI. Using 'gh repo create' flow.\");\n                gh_create_via_cli(\n                    &gh_cmd,\n                    directory,\n                    &repo_name,\n                    description.clone(),\n                    visibility,\n                )?;\n            } else {\n                log::info!(\"GitHub CLI not found. Falling back to API token auth.\");\n                log::debug!(\"PATH: {}\", env::var(\"PATH\").unwrap_or_default());\n                let rt = Runtime::new()?;\n                let created_repo = rt.block_on(gh_create_api(\n                    &repo_name,\n                    description.as_deref(),\n                    visibility,\n                ))?;\n                // Use the HTTPS clone URL from the created repository.\n                let remote_url = created_repo\n                    .clone_url\n                    .ok_or(\"GitHub repository did not return a clone URL\")?;\n                // Add the remote \"origin\" to the local repository.\n                add_remote(directory, \"origin\", remote_url.as_str())?;\n                // Automatically push the current branch.\n                gh_push(directory, \"origin\")?;\n            }\n        }\n        Commands::GhPush { directory, remote } => {\n            log::info!(\n                \"Pushing local repository '{}' to remote '{}'\",\n                directory,\n                remote\n            );\n            gh_push(directory, remote)?;\n        }\n        Commands::GhFetch { directory, remote } => {\n            log::info!(\n                \"Fetching remote changes for repository '{}' from '{}'\",\n                directory,\n                remote\n            );\n            gh_fetch(directory, remote)?;\n        }\n        Commands::GhSync { directory, remote } => {\n            log::info!(\n                \"Synchronizing local repository '{}' with remote '{}'\",\n                directory,\n                remote\n            );\n            gh_sync(directory, remote)?;\n        }\n        Commands::Tag {\n            directory,\n            version,\n            message,\n            no_push,\n            remote,\n            force,\n            allow_dirty,\n        } => {\n            log::info!(\"Tagging release in '{}'\", directory);\n            tag_release(\n                directory,\n                version.clone(),\n                message.clone(),\n                !*no_push,\n                remote,\n                *force,\n                *allow_dirty,\n                cli.dry_run,\n            )?;\n        }\n    }\n    Ok(())\n}\n\nfn main() {\n    // Initialize env_logger with a custom format:\n    // - For error-level logs, print \"Error:\" in light blue.\n    env_logger::Builder::new()\n        .format(|buf, record| {\n            if record.level() == log::Level::Error {\n                writeln!(buf, \"{}Error:{} {}\", BLUE, RESET, record.args())\n            } else {\n                writeln!(buf, \"{}\", record.args())\n            }\n        })\n        .filter(None, log::LevelFilter::Info)\n        .init();\n\n    if let Err(e) = run() {\n        eprintln!(\"{}Error:{} {}\", BLUE, RESET, e);\n        std::process::exit(1);\n    }\n}\n\n/// Read `[package].version` from `Cargo.toml` in `dir`.\nfn read_version_from_cargo_toml(dir: &str) -> Result<Option<String>, Box<dyn Error>> {\n    let cargo_toml_path = Path::new(dir).join(\"Cargo.toml\");\n    if !cargo_toml_path.exists() {\n        return Ok(None);\n    }\n    let contents = fs::read_to_string(&cargo_toml_path)?;\n    let value: toml::Value = contents.parse::<toml::Value>()?;\n    if let Some(pkg) = value.get(\"package\") {\n        if let Some(ver) = pkg.get(\"version\").and_then(|v| v.as_str()) {\n            return Ok(Some(ver.to_string()));\n        }\n    }\n    Ok(None)\n}\n\n/// Check if working tree has uncommitted changes in tracked files.\n/// Ignores untracked files and whitespace/EOL-only changes.\n#[allow(dead_code)]\nfn is_dirty(dir: &str) -> Result<bool, Box<dyn Error>> {\n    let repo = Repository::open(dir)?;\n    // No commits yet => not dirty for our purposes.\n    if repo.head().is_err() {\n        return Ok(false);\n    }\n\n    // First, use libgit2 statuses to see if any tracked files are modified or staged.\n    let mut opts = git2::StatusOptions::new();\n    opts.include_untracked(false)\n        .include_ignored(false)\n        .recurse_untracked_dirs(false)\n        .exclude_submodules(true)\n        .renames_head_to_index(true)\n        .show(git2::StatusShow::IndexAndWorkdir);\n    let statuses = repo.statuses(Some(&mut opts))?;\n    let mut has_candidate_changes = false;\n    for s in statuses.iter() {\n        let st = s.status();\n        if st.intersects(\n            git2::Status::INDEX_NEW\n                | git2::Status::INDEX_MODIFIED\n                | git2::Status::INDEX_DELETED\n                | git2::Status::INDEX_RENAMED\n                | git2::Status::INDEX_TYPECHANGE\n                | git2::Status::WT_MODIFIED\n                | git2::Status::WT_DELETED\n                | git2::Status::WT_RENAMED\n                | git2::Status::WT_TYPECHANGE,\n        ) {\n            has_candidate_changes = true;\n            break;\n        }\n    }\n    if !has_candidate_changes {\n        return Ok(false);\n    }\n\n    // If there are candidate changes, confirm by byte-compare after normalizing EOL.\n    let workdir = repo.workdir().ok_or(\"No workdir\")?;\n    let head_tree = repo.head()?.peel_to_tree()?;\n\n    fn normalize_eol(data: Vec<u8>) -> Vec<u8> {\n        // Replace CRLF with LF\n        let mut out = Vec::with_capacity(data.len());\n        let mut i = 0;\n        while i < data.len() {\n            if i + 1 < data.len() && data[i] == b'\\r' && data[i + 1] == b'\\n' {\n                out.push(b'\\n');\n                i += 2;\n            } else {\n                out.push(data[i]);\n                i += 1;\n            }\n        }\n        out\n    }\n\n    for s in statuses.iter() {\n        let st = s.status();\n        if !(st.intersects(\n            git2::Status::INDEX_NEW\n                | git2::Status::INDEX_MODIFIED\n                | git2::Status::INDEX_DELETED\n                | git2::Status::INDEX_RENAMED\n                | git2::Status::INDEX_TYPECHANGE\n                | git2::Status::WT_MODIFIED\n                | git2::Status::WT_DELETED\n                | git2::Status::WT_RENAMED\n                | git2::Status::WT_TYPECHANGE,\n        )) {\n            continue;\n        }\n        // If staged new/deleted/typechange exists, it is dirty.\n        if st.intersects(\n            git2::Status::INDEX_NEW | git2::Status::INDEX_DELETED | git2::Status::INDEX_TYPECHANGE,\n        ) {\n            #[cfg(test)]\n            eprintln!(\n                \"is_dirty: staged-change status={:?} path={:?}\",\n                st,\n                s.path()\n            );\n            return Ok(true);\n        }\n        // Compare HEAD blob vs workdir after normalizing EOL; if equal, ignore.\n        if let Some(rel) = s.path() {\n            let head_entry = head_tree.get_path(Path::new(rel));\n            if let Ok(head_entry) = head_entry {\n                if let Ok(blob) = repo.find_blob(head_entry.id()) {\n                    let head_bytes = normalize_eol(blob.content().to_vec());\n                    let wt_path = workdir.join(rel);\n                    if let Ok(wt_bytes_raw) = std::fs::read(&wt_path) {\n                        let wt_bytes = normalize_eol(wt_bytes_raw);\n                        if head_bytes == wt_bytes {\n                            continue; // spurious EOL-only change; ignore\n                        } else {\n                            #[cfg(test)]\n                            eprintln!(\n                                \"is_dirty: content-diff path={} head_len={} wt_len={}\",\n                                rel,\n                                head_bytes.len(),\n                                wt_bytes.len()\n                            );\n                            return Ok(true);\n                        }\n                    } else {\n                        #[cfg(test)]\n                        eprintln!(\"is_dirty: worktree read failed path={}\", rel);\n                        return Ok(true);\n                    }\n                } else {\n                    #[cfg(test)]\n                    eprintln!(\"is_dirty: blob lookup failed path={}\", rel);\n                    return Ok(true);\n                }\n            } else {\n                // Not found in HEAD (renamed?), consider dirty.\n                #[cfg(test)]\n                eprintln!(\"is_dirty: path not in HEAD: {}\", rel);\n                return Ok(true);\n            }\n        }\n    }\n    Ok(false)\n}\n\n/// Normalize and validate a semver string, enforcing a leading 'v' in the tag.\nfn normalize_semver_tag(input: &str) -> Result<(SemverVersion, String), Box<dyn Error>> {\n    let trimmed = input.trim().trim_start_matches('v');\n    let parsed = SemverVersion::parse(trimmed)?;\n    let tag = format!(\"v{}\", parsed);\n    Ok((parsed, tag))\n}\n\n/// Create an annotated tag for the current HEAD.\n#[allow(clippy::too_many_arguments)]\nfn tag_release(\n    directory: &str,\n    version_flag: Option<String>,\n    message_flag: Option<String>,\n    push: bool,\n    remote: &str,\n    force: bool,\n    allow_dirty: bool,\n    dry_run: bool,\n) -> Result<(), Box<dyn Error>> {\n    let repo = Repository::open(directory)?;\n\n    if !allow_dirty && is_dirty(directory)? {\n        return Err(\n            \"working tree has uncommitted changes; use --allow-dirty to create a tag anyway\".into(),\n        );\n    }\n\n    // Determine version: CLI flag > Cargo.toml > prompt\n    let version_str = if let Some(v) = version_flag {\n        v\n    } else if let Some(v) = read_version_from_cargo_toml(directory)? {\n        log::info!(\"Using version from Cargo.toml: {}\", v);\n        v\n    } else {\n        print!(\"Enter version (e.g., 0.1.0): \");\n        io::stdout().flush()?;\n        let mut buf = String::new();\n        io::stdin().read_line(&mut buf)?;\n        buf.trim().to_string()\n    };\n\n    // Validate and normalize to tag name with leading 'v'\n    let (_semver, tag_name) = normalize_semver_tag(&version_str)?;\n    // Ensure message; default to tag name itself (e.g., \"v0.1.0\").\n    let message = message_flag.unwrap_or_else(|| tag_name.clone());\n\n    // Check existing tag\n    let tag_ref_name = format!(\"refs/tags/{}\", tag_name);\n    let exists = repo.find_reference(&tag_ref_name).is_ok();\n    if exists && !force {\n        return Err(format!(\n            \"tag '{}' already exists; use --force to overwrite\",\n            tag_name\n        )\n        .into());\n    }\n\n    if dry_run {\n        log::info!(\n            \"[dry-run] Would run: git -C {} tag -a {}{} -m \\\"{}\\\"\",\n            directory,\n            tag_name,\n            if force { \" -f\" } else { \"\" },\n            message\n        );\n        if push {\n            log::info!(\n                \"[dry-run] Would run: git -C {} push {} {}\",\n                directory,\n                remote,\n                tag_name\n            );\n        }\n        return Ok(());\n    }\n\n    // Create or update annotated tag via git CLI (matches user's expectation).\n    let mut tag_args = vec![\"-C\", directory, \"tag\", \"-a\", &tag_name, \"-m\", &message];\n    if exists && !force {\n        return Err(format!(\n            \"tag '{}' already exists; use --force to overwrite\",\n            tag_name\n        )\n        .into());\n    }\n    if force {\n        // If --force was requested, add -f to update the tag.\n        tag_args.push(\"-f\");\n    }\n    let status = Command::new(\"git\").args(&tag_args).status()?;\n    if !status.success() {\n        return Err(\"failed to create tag via git\".into());\n    }\n    println!(\"Created tag '{}'\", tag_name);\n\n    if push {\n        // Validate remote exists\n        repo.find_remote(remote)\n            .map_err(|_| format!(\"remote '{}' not found\", remote))?;\n        let status = Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(directory)\n            .arg(\"push\")\n            .arg(remote)\n            .arg(&tag_name)\n            .status()?;\n        if !status.success() {\n            return Err(\"failed to push tag\".into());\n        }\n        println!(\"Pushed tag '{}' to '{}'\", tag_name, remote);\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests_tag {\n    use super::*;\n    use std::fs::File;\n    use std::io::Write as IoWrite;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_normalize_semver_tag_variants() {\n        let (_, t1) = normalize_semver_tag(\"1.2.3\").unwrap();\n        assert_eq!(t1, \"v1.2.3\");\n        let (_, t2) = normalize_semver_tag(\"v1.2.3\").unwrap();\n        assert_eq!(t2, \"v1.2.3\");\n        let (_, t3) = normalize_semver_tag(\"  v2.0.0  \").unwrap();\n        assert_eq!(t3, \"v2.0.0\");\n    }\n\n    #[test]\n    fn test_read_version_from_cargo_toml() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"Cargo.toml\");\n        let mut f = File::create(&path).unwrap();\n        writeln!(\n            f,\n            \"[package]\\nname=\\\"x\\\"\\nversion=\\\"0.9.1\\\"\\nedition=\\\"2021\\\"\\n\"\n        )\n        .unwrap();\n        let v = read_version_from_cargo_toml(dir.path().to_str().unwrap()).unwrap();\n        assert_eq!(v, Some(\"0.9.1\".to_string()));\n    }\n\n    #[test]\n    fn test_is_dirty_ignores_untracked() {\n        if !check_git_installed() {\n            eprintln!(\"git not installed; skipping test\");\n            return;\n        }\n        let dir = tempdir().unwrap();\n        let d = dir.path();\n        // init repo\n        std::process::Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(d)\n            .arg(\"init\")\n            .status()\n            .unwrap();\n        // configure local git identity\n        std::process::Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(d)\n            .arg(\"config\")\n            .arg(\"user.name\")\n            .arg(\"mdcode-test\")\n            .status()\n            .unwrap();\n        std::process::Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(d)\n            .arg(\"config\")\n            .arg(\"user.email\")\n            .arg(\"mdcode@test.local\")\n            .status()\n            .unwrap();\n\n        // Ensure consistent line ending behavior on Windows to avoid false positives\n        // when checking for dirty state in tests.\n        std::process::Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(d)\n            .arg(\"config\")\n            .arg(\"core.autocrlf\")\n            .arg(\"false\")\n            .status()\n            .unwrap();\n        std::process::Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(d)\n            .arg(\"config\")\n            .arg(\"core.filemode\")\n            .arg(\"false\")\n            .status()\n            .unwrap();\n\n        // create tracked file and commit\n        let mut tf = File::create(d.join(\"tracked.txt\")).unwrap();\n        writeln!(tf, \"hello\").unwrap();\n        drop(tf); // ensure contents are flushed before adding\n        std::process::Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(d)\n            .arg(\"add\")\n            .arg(\"tracked.txt\")\n            .status()\n            .unwrap();\n        std::process::Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(d)\n            .arg(\"commit\")\n            .arg(\"-m\")\n            .arg(\"init\")\n            .status()\n            .unwrap();\n        // create an untracked file\n        let mut uf = File::create(d.join(\"untracked.txt\")).unwrap();\n        writeln!(uf, \"temp\").unwrap();\n        // is_dirty should be false (ignoring untracked)\n        assert_eq!(is_dirty(d.to_str().unwrap()).unwrap(), false);\n        // modify tracked file to make it dirty\n        let mut tf2 = File::create(d.join(\"tracked.txt\")).unwrap();\n        writeln!(tf2, \"more\").unwrap();\n        drop(tf2);\n        assert_eq!(is_dirty(d.to_str().unwrap()).unwrap(), true);\n    }\n\n    #[test]\n    fn test_tag_release_dirty_requires_flag() {\n        if !check_git_installed() {\n            eprintln!(\"git not installed; skipping test\");\n            return;\n        }\n        let dir = tempdir().unwrap();\n        let repo_dir = dir.path().join(\"repo\");\n        let repo_str = repo_dir.to_str().unwrap();\n        new_repository(repo_str, false, 50).unwrap();\n        // Modify tracked .gitignore to make repository dirty.\n        use std::io::Write as _;\n        let mut gitignore = std::fs::OpenOptions::new()\n            .append(true)\n            .open(repo_dir.join(\".gitignore\"))\n            .unwrap();\n        writeln!(gitignore, \"# dirty\").unwrap();\n        drop(gitignore);\n\n        let err = tag_release(\n            repo_str,\n            Some(\"1.2.3\".to_string()),\n            None,\n            false,\n            \"origin\",\n            false,\n            false,\n            true,\n        )\n        .unwrap_err();\n        assert!(\n            err.to_string().contains(\"working tree\"),\n            \"expected dirty tree error, got {}\",\n            err\n        );\n\n        tag_release(\n            repo_str,\n            Some(\"1.2.3\".to_string()),\n            None,\n            false,\n            \"origin\",\n            false,\n            true,\n            true,\n        )\n        .unwrap();\n    }\n}\n\n#[cfg(test)]\nmod tests_detect_and_cap {\n    use super::*;\n    use std::io::Write as IoWrite;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_detect_file_type_audio_fonts_and_textlike() {\n        assert_eq!(detect_file_type(Path::new(\"x.wav\")), Some(\"Audio\"));\n        assert_eq!(detect_file_type(Path::new(\"x.MP3\")), Some(\"Audio\"));\n        assert_eq!(detect_file_type(Path::new(\"x.flac\")), Some(\"Audio\"));\n        assert_eq!(detect_file_type(Path::new(\"x.ipynb\")), Some(\"Notebook\"));\n        assert_eq!(detect_file_type(Path::new(\"x.proto\")), Some(\"Protobuf\"));\n        assert_eq!(detect_file_type(Path::new(\"x.gql\")), Some(\"GraphQL\"));\n        assert_eq!(detect_file_type(Path::new(\"x.thrift\")), Some(\"Thrift\"));\n        assert_eq!(detect_file_type(Path::new(\"x.r\")), Some(\"R\"));\n        assert_eq!(detect_file_type(Path::new(\"x.jl\")), Some(\"Julia\"));\n        assert_eq!(detect_file_type(Path::new(\"x.mm\")), Some(\"Objective-C++\"));\n        assert_eq!(detect_file_type(Path::new(\"x.ttf\")), Some(\"Font\"));\n        assert_eq!(detect_file_type(Path::new(\"x.woff2\")), Some(\"Font\"));\n    }\n\n    #[test]\n    fn test_detect_file_type_special_filenames() {\n        assert_eq!(detect_file_type(Path::new(\"LICENSE\")), Some(\"License\"));\n        assert_eq!(\n            detect_file_type(Path::new(\"Dockerfile\")),\n            Some(\"Build Script\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"Makefile\")),\n            Some(\"Build Script\")\n        );\n        assert_eq!(detect_file_type(Path::new(\"CMakeLists.txt\")), Some(\"CMake\"));\n    }\n\n    #[test]\n    fn test_detect_file_type_installer_scripts() {\n        assert_eq!(\n            detect_file_type(Path::new(\"setup.iss\")),\n            Some(\"Installer Script\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"SETUP.ISS\")),\n            Some(\"Installer Script\")\n        );\n    }\n\n    #[test]\n    fn test_detect_file_type_lockfiles() {\n        assert_eq!(detect_file_type(Path::new(\"Cargo.lock\")), Some(\"Lockfile\"));\n        assert_eq!(\n            detect_file_type(Path::new(\"Gemfile.lock\")),\n            Some(\"Lockfile\")\n        );\n        assert_eq!(detect_file_type(Path::new(\"yarn.lock\")), Some(\"Lockfile\"));\n    }\n\n    #[test]\n    fn test_scan_source_files_respects_size_cap() {\n        let dir = tempdir().unwrap();\n        let d = dir.path();\n        // small recognized file\n        let mut f_small = File::create(d.join(\"small.wav\")).unwrap();\n        f_small.write_all(&vec![0u8; 1024]).unwrap(); // 1 KB\n\n        // large recognized file (~2 MB)\n        let mut f_large = File::create(d.join(\"large.mp3\")).unwrap();\n        f_large.write_all(&vec![1u8; 2 * 1024 * 1024]).unwrap();\n\n        // cap = 1 MB\n        let (files, count) = scan_source_files(d.to_str().unwrap(), 1).unwrap();\n        let names: Vec<String> = files\n            .iter()\n            .map(|p| p.file_name().unwrap().to_string_lossy().to_string())\n            .collect();\n        assert_eq!(count, 1);\n        assert!(names.contains(&\"small.wav\".to_string()));\n        assert!(!names.contains(&\"large.mp3\".to_string()));\n    }\n\n    #[test]\n    fn test_scan_respects_gitignore() {\n        let dir = tempdir().unwrap();\n        let d = dir.path();\n        // Recognized file we will ignore via .gitignore\n        std::fs::write(d.join(\"README.md\"), b\"Ignored doc\").unwrap();\n        std::fs::write(d.join(\".gitignore\"), b\"# ignore readme\\nREADME.md\\n\").unwrap();\n        // Another recognized file that should remain\n        std::fs::write(\n            d.join(\"Cargo.toml\"),\n            b\"[package]\\nname='x'\\nversion='0.1.0'\\n\",\n        )\n        .unwrap();\n\n        let (files, _count) = scan_source_files(d.to_str().unwrap(), 50).unwrap();\n        let names: Vec<String> = files\n            .iter()\n            .map(|p| p.file_name().unwrap().to_string_lossy().to_string())\n            .collect();\n        assert!(names.contains(&\"Cargo.toml\".to_string()));\n        assert!(!names.contains(&\"README.md\".to_string()));\n    }\n\n    #[test]\n    fn test_scan_includes_lockfiles() {\n        let dir = tempdir().unwrap();\n        let d = dir.path();\n        std::fs::write(d.join(\"Cargo.lock\"), b\"[[package]]\").unwrap();\n        std::fs::write(d.join(\"Gemfile.lock\"), b\"GEM\\n\").unwrap();\n\n        let (files, _count) = scan_source_files(d.to_str().unwrap(), 50).unwrap();\n        let names: Vec<String> = files\n            .iter()\n            .map(|p| p.file_name().unwrap().to_string_lossy().to_string())\n            .collect();\n        assert!(names.contains(&\"Cargo.lock\".to_string()));\n        assert!(names.contains(&\"Gemfile.lock\".to_string()));\n    }\n\n    #[test]\n    fn test_scan_ignores_target_ci() {\n        let dir = tempdir().unwrap();\n        let d = dir.path();\n        // Simulate Rust CI build artifact under target_ci\n        let fp = d.join(\"target_ci\").join(\"debug\").join(\".fingerprint\");\n        std::fs::create_dir_all(&fp).unwrap();\n        std::fs::write(fp.join(\"lib-anyhow.json\"), b\"{}\").unwrap();\n        // A legitimate source/config file in the root\n        std::fs::write(\n            d.join(\"Cargo.toml\"),\n            b\"[package]\\nname='x'\\nversion='0.1.0'\\n\",\n        )\n        .unwrap();\n\n        let (files, _count) = scan_source_files(d.to_str().unwrap(), 50).unwrap();\n        let names: Vec<String> = files\n            .iter()\n            .map(|p| p.strip_prefix(d).unwrap().to_string_lossy().to_string())\n            .collect();\n        assert!(names.iter().any(|n| n == \"Cargo.toml\"));\n        assert!(\n            !names\n                .iter()\n                .any(|n| n.contains(\"target_ci\") || n.contains(\".fingerprint\")),\n            \"should ignore files under target_ci\"\n        );\n    }\n}\n\n/// Returns true if any component of the entry's path is an excluded directory.\n///\n/// The tool ignores common build and virtual environment folders: `target`,\n/// `target_ci` (Rust CI artifacts), `bin`, `obj`, `venv`, `.venv`, and `env`.\nfn is_in_excluded_path(path: &Path) -> bool {\n    path.components()\n        .any(|comp| match comp.as_os_str().to_str() {\n            Some(\"target\") | Some(\"target_ci\") => true,\n            Some(\"bin\") | Some(\"obj\") => true,\n            Some(\"venv\") | Some(\".venv\") | Some(\"env\") => true,\n            // Always skip VCS metadata directories if encountered during a walk.\n            Some(\".git\") | Some(\".hg\") | Some(\".svn\") => true,\n            _ => false,\n        })\n}\n\n/// Create a new repository and make an initial commit.\nfn new_repository(dir: &str, dry_run: bool, max_file_mb: u64) -> Result<(), Box<dyn Error>> {\n    if !check_git_installed() {\n        log::error!(\"Git is not installed. Please install Git from https://git-scm.com/downloads\");\n        return Err(\"Git not installed\".into());\n    }\n\n    if Path::new(dir).exists() {\n        if let Ok(repo) = Repository::open(dir) {\n            if repo.head().is_ok() {\n                log::error!(\"git repository already exists in directory '{}'\", dir);\n                return Err(\"git repository already exists\".into());\n            }\n        }\n    }\n\n    let total_files = scan_total_files(dir)?;\n    let (mut source_files, _source_count) = scan_source_files(dir, max_file_mb)?;\n    let gitignore_path = Path::new(dir).join(\".gitignore\");\n    if !source_files.iter().any(|p| p == &gitignore_path) {\n        source_files.push(gitignore_path);\n    }\n\n    if !Path::new(dir).exists() {\n        log::info!(\"Directory '{}' does not exist. Creating...\", dir);\n        if !dry_run {\n            fs::create_dir_all(dir)?;\n        }\n    }\n    if dry_run {\n        log::info!(\"Dry run enabled - repository will not be created.\");\n    }\n\n    let added_count = if dry_run {\n        source_files.len()\n    } else {\n        let repo = Repository::init(dir)?;\n\n        log::info!(\"Initializing Git repository...\");\n        create_gitignore(dir, false)?;\n        let count = add_files_to_git(dir, &source_files, false)?;\n\n        let mut index = repo.index()?;\n        index.write()?;\n        let tree_id = index.write_tree()?;\n        let tree = repo.find_tree(tree_id)?;\n        let (signature, sig_src) = resolve_signature_with_source(&repo)?;\n        log::info!(\n            \"Using Git author: {} <{}> (source: {})\",\n            signature.name().unwrap_or(\"(unknown)\"),\n            signature.email().unwrap_or(\"(unknown)\"),\n            sig_src\n        );\n        repo.commit(\n            Some(\"HEAD\"),\n            &signature,\n            &signature,\n            \"Initial commit\",\n            &tree,\n            &[],\n        )?;\n        count\n    };\n\n    log::info!(\n        \"{}New files added:{} {}\",\n        BLUE,\n        RESET,\n        source_files\n            .iter()\n            .map(|p| format!(\"{}{}{}\", GREEN, p.to_string_lossy(), RESET))\n            .collect::<Vec<String>>()\n            .join(\", \")\n    );\n    log::info!(\n        \"{}Final result:{} {}{} source files added out of {} total files{}\",\n        BLUE,\n        RESET,\n        YELLOW,\n        added_count,\n        total_files,\n        RESET\n    );\n\n    Ok(())\n}\n\n/// Update an existing repository by staging changes and creating a commit.\n/// After staging, if commit_msg is None the user is prompted for a commit message (defaulting to \"Updated files\").\nfn update_repository(\n    dir: &str,\n    dry_run: bool,\n    commit_msg: Option<&str>,\n    max_file_mb: u64,\n) -> Result<(), Box<dyn Error>> {\n    let repo = match Repository::open(dir) {\n        Ok(r) => r,\n        Err(_) => {\n            log::error!(\n                \"{}Error:{} No git repository in directory '{}'\",\n                BLUE,\n                RESET,\n                dir\n            );\n            return Err(\"No git repository\".into());\n        }\n    };\n    log::info!(\"Staging changes...\");\n    let parent_commit = get_last_commit(&repo)?;\n    let parent_tree = parent_commit.tree()?;\n    let (source_files, _) = scan_source_files(dir, max_file_mb)?;\n    let _ = add_files_to_git(dir, &source_files, dry_run)?;\n    if !dry_run {\n        let status = Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(dir)\n            .arg(\"add\")\n            .arg(\"-u\")\n            .status()?;\n        if !status.success() {\n            return Err(\"git add -u failed\".into());\n        }\n    }\n\n    if dry_run {\n        let mut opts = DiffOptions::new();\n        opts.include_untracked(true);\n        let diff = repo.diff_tree_to_workdir_with_index(Some(&parent_tree), Some(&mut opts))?;\n        let mut changed_files = Vec::new();\n        diff.foreach(\n            &mut |delta, _| {\n                match delta.status() {\n                    Delta::Added => {\n                        if let Some(path) = delta.new_file().path() {\n                            changed_files.push(format!(\n                                \"{}{}{}\",\n                                GREEN,\n                                path.to_string_lossy(),\n                                RESET\n                            ));\n                        }\n                    }\n                    Delta::Deleted => {\n                        if let Some(path) = delta.old_file().path() {\n                            changed_files.push(format!(\n                                \"{}{}{}\",\n                                RED,\n                                path.to_string_lossy(),\n                                RESET\n                            ));\n                        }\n                    }\n                    _ => {\n                        if let Some(path) = delta.new_file().path().or(delta.old_file().path()) {\n                            changed_files.push(path.to_string_lossy().to_string());\n                        }\n                    }\n                }\n                true\n            },\n            None,\n            None,\n            None,\n        )?;\n        if changed_files.is_empty() {\n            log::info!(\"No changes to commit.\");\n            return Ok(());\n        }\n        log::info!(\"{}Changed:{} {}\", BLUE, RESET, changed_files.join(\", \"));\n        let final_message = if let Some(msg) = commit_msg {\n            msg.to_string()\n        } else {\n            \"Updated files\".to_string()\n        };\n        log::info!(\n            \"[dry-run] Would create commit '{}' affecting {} files.\",\n            final_message,\n            changed_files.len()\n        );\n        return Ok(());\n    }\n\n    let mut index = repo.index()?;\n    index.write()?;\n    let new_tree_id = index.write_tree()?;\n    if new_tree_id == parent_tree.id() {\n        log::info!(\"No changes to commit.\");\n        return Ok(());\n    }\n    let new_tree = repo.find_tree(new_tree_id)?;\n    let diff = repo.diff_tree_to_tree(Some(&parent_tree), Some(&new_tree), None)?;\n    let mut changed_files = Vec::new();\n    diff.foreach(\n        &mut |delta, _| {\n            match delta.status() {\n                Delta::Added => {\n                    if let Some(path) = delta.new_file().path() {\n                        changed_files.push(format!(\"{}{}{}\", GREEN, path.to_string_lossy(), RESET));\n                    }\n                }\n                Delta::Deleted => {\n                    if let Some(path) = delta.old_file().path() {\n                        changed_files.push(format!(\"{}{}{}\", RED, path.to_string_lossy(), RESET));\n                    }\n                }\n                _ => {\n                    if let Some(path) = delta.new_file().path().or(delta.old_file().path()) {\n                        changed_files.push(path.to_string_lossy().to_string());\n                    }\n                }\n            }\n            true\n        },\n        None,\n        None,\n        None,\n    )?;\n    log::info!(\"{}Changed:{} {}\", BLUE, RESET, changed_files.join(\", \"));\n\n    // Determine commit message.\n    let final_message = if let Some(msg) = commit_msg {\n        msg.to_string()\n    } else {\n        print!(\"Enter commit message [default: Updated files]: \");\n        io::stdout().flush()?;\n        let mut msg = String::new();\n        io::stdin().read_line(&mut msg)?;\n        if msg.trim().is_empty() {\n            \"Updated files\".to_string()\n        } else {\n            msg.trim().to_string()\n        }\n    };\n\n    log::info!(\"{}Creating commit:{} '{}'\", BLUE, RESET, final_message);\n    let (signature, sig_src) = resolve_signature_with_source(&repo)?;\n    log::info!(\n        \"Using Git author: {} <{}> (source: {})\",\n        signature.name().unwrap_or(\"(unknown)\"),\n        signature.email().unwrap_or(\"(unknown)\"),\n        sig_src\n    );\n    repo.commit(\n        Some(\"HEAD\"),\n        &signature,\n        &signature,\n        &final_message,\n        &new_tree,\n        &[&parent_commit],\n    )?;\n    log::info!(\n        \"{}{} changes staged and committed.{}\",\n        YELLOW,\n        changed_files.len(),\n        RESET\n    );\n    Ok(())\n}\n\n/// Scan the entire directory tree and count total files, skipping any entries under excluded directories.\nfn scan_total_files(dir: &str) -> Result<usize, Box<dyn Error>> {\n    log::debug!(\"Scanning source tree in '{}'...\", dir);\n    let mut total = 0;\n    // Build a local .gitignore matcher (best-effort); ignore walker should\n    // already respect .gitignore, but we also guard in-code to be explicit.\n    let gi = {\n        let mut b = GitignoreBuilder::new(dir);\n        let _ = b.add(Path::new(dir).join(\".gitignore\"));\n        b.build().ok()\n    };\n    for result in IgnoreWalkBuilder::new(dir)\n        .hidden(false)\n        .git_ignore(true)\n        .git_global(true)\n        .git_exclude(true)\n        .ignore(true)\n        .build()\n    {\n        let entry = match result {\n            Ok(e) => e,\n            Err(_) => continue,\n        };\n        let path = entry.path();\n        if is_in_excluded_path(path) {\n            continue;\n        }\n        if let Some(ref m) = gi {\n            if m.matched_path_or_any_parents(\n                path,\n                entry.file_type().map(|ft| ft.is_dir()).unwrap_or(false),\n            )\n            .is_ignore()\n            {\n                continue;\n            }\n        }\n        if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {\n            total += 1;\n        }\n    }\n    log::debug!(\"Scan complete - found {} files\", total);\n    Ok(total)\n}\n\n/// Scan for source files (ignoring files under excluded directories).\nfn scan_source_files(dir: &str, max_file_mb: u64) -> Result<(Vec<PathBuf>, usize), Box<dyn Error>> {\n    log::debug!(\"Scanning for source files in '{}'...\", dir);\n    let mut source_files = Vec::new();\n    let mut count = 0;\n    let cap_bytes: u64 = max_file_mb.saturating_mul(1024).saturating_mul(1024);\n    let gi = {\n        let mut b = GitignoreBuilder::new(dir);\n        let _ = b.add(Path::new(dir).join(\".gitignore\"));\n        b.build().ok()\n    };\n    for result in IgnoreWalkBuilder::new(dir)\n        .hidden(false)\n        .git_ignore(true)\n        .git_global(true)\n        .git_exclude(true)\n        .ignore(true)\n        .build()\n    {\n        let entry = match result {\n            Ok(e) => e,\n            Err(_) => continue,\n        };\n        let path = entry.path();\n        if is_in_excluded_path(path) {\n            continue;\n        }\n        if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {\n            if let Some(ref m) = gi {\n                if m.matched_path_or_any_parents(path, false).is_ignore() {\n                    continue;\n                }\n            }\n            if detect_file_type(path).is_some() {\n                if let Ok(meta) = fs::metadata(path) {\n                    if meta.len() > cap_bytes {\n                        log::info!(\n                            \"Ignoring '{}' as larger than {} MB - use '--max-file-mb'\",\n                            path.display(),\n                            max_file_mb\n                        );\n                        continue;\n                    }\n                }\n                source_files.push(path.to_path_buf());\n                count += 1;\n            }\n        }\n    }\n    log::debug!(\"{} source files found\", count);\n    Ok((source_files, count))\n}\n\n/// Add the provided source files to the Git index.\nfn add_files_to_git(dir: &str, files: &[PathBuf], dry_run: bool) -> Result<usize, Box<dyn Error>> {\n    let repo = Repository::open(dir)?;\n    let mut index = repo.index()?;\n    for file in files {\n        if !dry_run {\n            let relative_path = file.strip_prefix(dir).unwrap_or(file);\n            index.add_path(relative_path)?;\n        }\n    }\n    index.write()?;\n    log::debug!(\"Added {} files to Git\", files.len());\n    Ok(files.len())\n}\n\n/// Check if Git is installed.\nfn check_git_installed() -> bool {\n    if let Ok(output) = Command::new(\"git\").arg(\"--version\").output() {\n        output.status.success()\n    } else {\n        false\n    }\n}\n\n/// Retrieve the last commit from the repository.\nfn get_last_commit(repo: &Repository) -> Result<git2::Commit<'_>, Box<dyn Error>> {\n    let obj = repo.head()?.resolve()?.peel(ObjectType::Commit)?;\n    let commit = obj.into_commit().map_err(|_| \"Couldn't find commit\")?;\n    Ok(commit)\n}\n\n/// Retrieve a commit by index (0 is most recent, 1 is next, etc.).\nfn get_commit_by_index(repo: &Repository, idx: i32) -> Result<git2::Commit<'_>, Box<dyn Error>> {\n    let mut revwalk = repo.revwalk()?;\n    revwalk.push_head()?;\n    revwalk.set_sorting(Sort::TIME)?;\n    let commits: Vec<_> = revwalk.collect::<Result<Vec<_>, _>>()?;\n    if (idx as usize) < commits.len() {\n        repo.find_commit(commits[idx as usize])\n            .map_err(|e| e.into())\n    } else {\n        Err(\"Index out of bounds\".into())\n    }\n}\n\n/// Resolve the Git signature (name/email) and describe its source for logging.\nfn resolve_signature_with_source(\n    repo: &Repository,\n) -> Result<(Signature<'_>, String), Box<dyn Error>> {\n    if let (Ok(name), Ok(email)) = (\n        std::env::var(\"GIT_AUTHOR_NAME\"),\n        std::env::var(\"GIT_AUTHOR_EMAIL\"),\n    ) {\n        return Ok((\n            Signature::now(&name, &email)?,\n            \"env:GIT_AUTHOR_NAME/GIT_AUTHOR_EMAIL\".into(),\n        ));\n    }\n    if let (Ok(name), Ok(email)) = (\n        std::env::var(\"GIT_COMMITTER_NAME\"),\n        std::env::var(\"GIT_COMMITTER_EMAIL\"),\n    ) {\n        return Ok((\n            Signature::now(&name, &email)?,\n            \"env:GIT_COMMITTER_NAME/GIT_COMMITTER_EMAIL\".into(),\n        ));\n    }\n\n    if let Ok(cfg) = repo.config() {\n        let name = cfg.get_string(\"user.name\").ok();\n        let email = cfg.get_string(\"user.email\").ok();\n        if let (Some(name), Some(email)) = (name, email) {\n            return Ok((\n                Signature::now(&name, &email)?,\n                \"git config (repo/global)\".into(),\n            ));\n        }\n    }\n    if let Ok(cfg) = git2::Config::open_default() {\n        let name = cfg.get_string(\"user.name\").ok();\n        let email = cfg.get_string(\"user.email\").ok();\n        if let (Some(name), Some(email)) = (name, email) {\n            return Ok((Signature::now(&name, &email)?, \"git config (global)\".into()));\n        }\n    }\n\n    Ok((\n        Signature::now(\"mdcode\", \"mdcode@example.com\")?,\n        \"mdcode fallback\".into(),\n    ))\n}\n\n/// Retrieve the commit pointed to by the remote HEAD on GitHub.\nfn get_remote_head_commit<'repo>(\n    repo: &'repo Repository,\n    dir: &str,\n) -> Result<git2::Commit<'repo>, Box<dyn Error>> {\n    // Ensure the remote exists.\n    repo.find_remote(\"origin\")\n        .map_err(|_| \"Remote 'origin' not found\")?;\n\n    // Fetch the latest changes from the remote named \"origin\".\n    let fetch_status = Command::new(\"git\")\n        .arg(\"-C\")\n        .arg(dir)\n        .arg(\"fetch\")\n        .arg(\"origin\")\n        .status()?;\n    if !fetch_status.success() {\n        return Err(\"git fetch failed\".into());\n    }\n\n    // Try the symbolic origin/HEAD reference first.\n    let head_ref = match repo.find_reference(\"refs/remotes/origin/HEAD\") {\n        Ok(r) => r,\n        Err(_) => {\n            // Fallback: determine the default branch via `git remote show origin`.\n            let output = Command::new(\"git\")\n                .arg(\"-C\")\n                .arg(dir)\n                .arg(\"remote\")\n                .arg(\"show\")\n                .arg(\"origin\")\n                .output()?;\n            if !output.status.success() {\n                return Err(\"git remote show origin failed\".into());\n            }\n            let stdout = String::from_utf8_lossy(&output.stdout);\n            let branch = stdout\n                .lines()\n                .find(|l| l.trim_start().starts_with(\"HEAD branch:\"))\n                .and_then(|l| l.split(':').nth(1))\n                .map(|b| b.trim())\n                .ok_or(\"Unable to determine default branch on origin\")?;\n            let ref_name = format!(\"refs/remotes/origin/{}\", branch);\n            repo.find_reference(&ref_name)?\n        }\n    };\n\n    // origin/HEAD should normally be a symbolic ref to the default branch.\n    // However some remotes may create it as a direct ref to a commit.\n    // Try symbolic target first, falling back to the direct target if needed.\n    if let Some(target) = head_ref.symbolic_target() {\n        let branch_ref = repo.find_reference(target)?;\n        let oid = branch_ref.target().ok_or(\"Remote HEAD has no target\")?;\n        repo.find_commit(oid).map_err(|e| e.into())\n    } else if let Some(oid) = head_ref.target() {\n        // origin/HEAD points directly to a commit\n        repo.find_commit(oid).map_err(|e| e.into())\n    } else {\n        Err(\"origin/HEAD has no target\".into())\n    }\n}\n\n/// Diff commits based on provided version numbers.\nfn diff_command(dir: &str, versions: &[String], dry_run: bool) -> Result<(), Box<dyn Error>> {\n    let repo = Repository::open(dir)?;\n    let before_commit = if (versions.len() == 2 && versions[0].eq_ignore_ascii_case(\"H\"))\n        || (versions.len() == 1 && versions[0].eq_ignore_ascii_case(\"L\"))\n    {\n        get_remote_head_commit(&repo, dir)?\n    } else {\n        let idx = if versions.is_empty() {\n            0\n        } else {\n            versions[0]\n                .parse::<i32>()\n                .map_err(|_| \"invalid repo indexes specified\")?\n        };\n        match get_commit_by_index(&repo, idx) {\n            Ok(c) => c,\n            Err(_) => {\n                log::error!(\"{}Error:{} invalid repo indexes specified\", BLUE, RESET);\n                return Err(\"invalid repo indexes specified\".into());\n            }\n        }\n    };\n    let before_tree = before_commit.tree()?;\n    let before_timestamp = match Utc.timestamp_opt(before_commit.time().seconds(), 0) {\n        LocalResult::Single(dt) => dt.naive_utc().format(\"%Y-%m-%d_%H%M%S\").to_string(),\n        _ => return Err(\"Invalid timestamp\".into()),\n    };\n    let before_prefix = format!(\"before.{}.{}\", dir, before_timestamp);\n    let before_temp_dir = create_temp_dir(&before_prefix)?;\n    if !dry_run {\n        checkout_tree_to_dir(&repo, &before_tree, &before_temp_dir)?;\n    }\n    log::info!(\"Checked out 'before' snapshot to {:?}\", before_temp_dir);\n\n    let (after_dir, after_timestamp_str) =\n        if versions.len() == 1 && versions[0].to_uppercase() == \"L\" {\n            (PathBuf::from(dir), \"current\".to_string())\n        } else if versions.len() == 2 {\n            if versions[0].to_uppercase() == \"H\" {\n                let idx = versions[1]\n                    .parse::<i32>()\n                    .map_err(|_| \"invalid repo indexes specified\")?;\n                let after_commit = match get_commit_by_index(&repo, idx) {\n                    Ok(c) => c,\n                    Err(_) => {\n                        log::error!(\"{}Error:{} invalid repo indexes specified\", BLUE, RESET);\n                        return Err(\"invalid repo indexes specified\".into());\n                    }\n                };\n                let after_tree = after_commit.tree()?;\n                let after_timestamp = match Utc.timestamp_opt(after_commit.time().seconds(), 0) {\n                    LocalResult::Single(dt) => dt.naive_utc().format(\"%Y-%m-%d_%H%M%S\").to_string(),\n                    _ => return Err(\"Invalid timestamp\".into()),\n                };\n                let after_prefix = format!(\"after.{}.{}\", dir, after_timestamp);\n                let temp = create_temp_dir(&after_prefix)?;\n                if !dry_run {\n                    checkout_tree_to_dir(&repo, &after_tree, &temp)?;\n                }\n                log::info!(\"Checked out 'after' snapshot to {:?}\", temp);\n                (temp, after_timestamp)\n            } else {\n                let idx = versions[1]\n                    .parse::<i32>()\n                    .map_err(|_| \"invalid repo indexes specified\")?;\n                let after_commit = match get_commit_by_index(&repo, idx) {\n                    Ok(c) => c,\n                    Err(_) => {\n                        log::error!(\"{}Error:{} invalid repo indexes specified\", BLUE, RESET);\n                        return Err(\"invalid repo indexes specified\".into());\n                    }\n                };\n                let after_tree = after_commit.tree()?;\n                let after_timestamp = match Utc.timestamp_opt(after_commit.time().seconds(), 0) {\n                    LocalResult::Single(dt) => dt.naive_utc().format(\"%Y-%m-%d_%H%M%S\").to_string(),\n                    _ => return Err(\"Invalid timestamp\".into()),\n                };\n                let after_prefix = format!(\"after.{}.{}\", dir, after_timestamp);\n                let temp = create_temp_dir(&after_prefix)?;\n                if !dry_run {\n                    checkout_tree_to_dir(&repo, &after_tree, &temp)?;\n                }\n                log::info!(\"Checked out 'after' snapshot to {:?}\", temp);\n                (temp, after_timestamp)\n            }\n        } else {\n            (PathBuf::from(dir), \"current\".to_string())\n        };\n\n    log::info!(\n        \"{}Comparing {} with {}{}\",\n        YELLOW,\n        before_timestamp,\n        after_timestamp_str,\n        RESET\n    );\n\n    // Launch the diff tool only if not a dry run.\n    if !dry_run {\n        if let Err(e) = launch_diff_tool(&before_temp_dir, &after_dir) {\n            log::error!(\"Failed to launch diff tool: {}\", e);\n        }\n    }\n    Ok(())\n}\n\nfn launch_custom_diff_tool(\n    spec: &std::ffi::OsStr,\n    before: &Path,\n    after: &Path,\n) -> Result<bool, Box<dyn Error>> {\n    let spec_str = spec.to_string_lossy();\n    let parts = match shlex::split(&spec_str) {\n        Some(parts) if !parts.is_empty() => parts,\n        _ => {\n            log::warn!(\n                \"DIFF_TOOL value '{}' could not be parsed; skipping custom diff tool.\",\n                spec_str\n            );\n            return Ok(false);\n        }\n    };\n    let (cmd, args) = parts.split_first().unwrap();\n    match Command::new(cmd).args(args).arg(before).arg(after).spawn() {\n        Ok(_) => {\n            log::info!(\"Launched custom diff tool '{}'.\", cmd);\n            Ok(true)\n        }\n        Err(e) => {\n            log::warn!(\"Custom diff tool '{}' failed to launch: {}\", cmd, e);\n            Ok(false)\n        }\n    }\n}\n\nfn launch_program_with_args(\n    program: &str,\n    args: &[&str],\n    before: &Path,\n    after: &Path,\n    label: &str,\n) -> Result<bool, Box<dyn Error>> {\n    let mut command = Command::new(program);\n    command.args(args).arg(before).arg(after);\n    match command.spawn() {\n        Ok(_) => {\n            log::info!(\"Launched {}.\", label);\n            Ok(true)\n        }\n        Err(e) => {\n            log::debug!(\"{} failed to launch: {}\", label, e);\n            Ok(false)\n        }\n    }\n}\n\n/// Launch an external diff tool with sensible fallbacks per platform.\nfn launch_diff_tool(before: &Path, after: &Path) -> Result<(), Box<dyn Error>> {\n    if let Some(spec) = env::var_os(\"MDCODE_DIFF_TOOL\").or_else(|| env::var_os(\"DIFF_TOOL\")) {\n        if launch_custom_diff_tool(&spec, before, after)? {\n            return Ok(());\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        if launch_program_with_args(\"WinMergeU.exe\", &[], before, after, \"WinMergeU.exe\")? {\n            return Ok(());\n        }\n        if launch_program_with_args(\"windiff.exe\", &[], before, after, \"windiff.exe\")? {\n            return Ok(());\n        }\n    }\n\n    if launch_program_with_args(\"code\", &[\"--diff\"], before, after, \"VS Code --diff\")? {\n        return Ok(());\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        if launch_program_with_args(\"opendiff\", &[], before, after, \"opendiff\")? {\n            return Ok(());\n        }\n    }\n\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        if launch_program_with_args(\"meld\", &[], before, after, \"meld\")? {\n            return Ok(());\n        }\n    }\n\n    log::info!(\"Falling back to 'git diff --no-index'.\");\n    let status = Command::new(\"git\")\n        .arg(\"diff\")\n        .arg(\"--no-index\")\n        .arg(before)\n        .arg(after)\n        .status()?;\n    if status.success() {\n        Ok(())\n    } else {\n        Err(\"Failed to launch any diff tool (git diff --no-index returned error)\".into())\n    }\n}\n\n/// Detect file type based on file extension.\n/// Returns a string representing the files category if recognized.\nfn detect_file_type(file_path: &Path) -> Option<&'static str> {\n    // Recognize special filenames without extensions.\n    if let Some(file_name) = file_path.file_name()?.to_str() {\n        if file_name.eq_ignore_ascii_case(\"LICENSE\") {\n            return Some(\"License\");\n        }\n        if file_name.eq_ignore_ascii_case(\"Dockerfile\") {\n            return Some(\"Build Script\");\n        }\n        if file_name.eq_ignore_ascii_case(\"Makefile\") {\n            return Some(\"Build Script\");\n        }\n        if file_name.eq_ignore_ascii_case(\"CMakeLists.txt\") {\n            return Some(\"CMake\");\n        }\n    }\n\n    let extension = file_path.extension()?.to_str()?.to_lowercase();\n    match extension.as_str() {\n        // Source Code\n        \"c\" => Some(\"C\"),\n        \"cpp\" | \"cc\" | \"cxx\" => Some(\"C++\"),\n        \"h\" => Some(\"C/C++ Header\"),\n        \"hpp\" | \"hh\" | \"hxx\" => Some(\"C++ Header\"),\n        \"java\" => Some(\"Java\"),\n        \"py\" => Some(\"Python\"),\n        \"rb\" => Some(\"Ruby\"),\n        \"cs\" => Some(\"C#\"),\n        \"go\" => Some(\"Go\"),\n        \"php\" => Some(\"PHP\"),\n        \"rs\" => Some(\"Rust\"),\n        \"swift\" => Some(\"Swift\"),\n        \"kt\" | \"kts\" => Some(\"Kotlin\"),\n        \"scala\" => Some(\"Scala\"),\n        \"js\" | \"jsx\" => Some(\"JavaScript\"),\n        \"ts\" | \"tsx\" => Some(\"TypeScript\"),\n        \"sh\" | \"bash\" | \"zsh\" => Some(\"Shell Script\"),\n        \"bat\" => Some(\"Batch Script\"),\n        \"ps1\" => Some(\"PowerShell\"),\n        // Additional languages / build systems\n        \"r\" => Some(\"R\"),\n        \"jl\" => Some(\"Julia\"),\n        \"mm\" => Some(\"Objective-C++\"),\n        \"cmake\" => Some(\"CMake\"),\n        // APIs / IDL\n        \"proto\" => Some(\"Protobuf\"),\n        \"graphql\" | \"gql\" => Some(\"GraphQL\"),\n        \"thrift\" => Some(\"Thrift\"),\n        // Markup / Documentation\n        \"html\" | \"htm\" => Some(\"HTML\"),\n        \"css\" | \"scss\" | \"sass\" | \"less\" => Some(\"CSS\"),\n        \"xml\" => Some(\"XML\"),\n        \"json\" => Some(\"JSON\"),\n        \"yml\" | \"yaml\" => Some(\"YAML\"),\n        \"toml\" => Some(\"TOML\"),\n        \"lock\" => Some(\"Lockfile\"),\n        \"md\" | \"txt\" | \"rst\" | \"adoc\" => Some(\"Documentation\"),\n        \"ipynb\" => Some(\"Notebook\"),\n        // Configuration / Build\n        \"ini\" | \"cfg\" | \"conf\" => Some(\"Configuration\"),\n        \"sln\" => Some(\"Solution File\"),\n        \"csproj\" => Some(\"C# Project File\"),\n        \"pom\" => Some(\"Maven Project File\"),\n        \"gradle\" => Some(\"Gradle Build File\"),\n        // Installer scripts\n        \"iss\" => Some(\"Installer Script\"),\n        // Database\n        \"sql\" => Some(\"SQL\"),\n        // Images & Assets\n        \"jpg\" | \"jpeg\" => Some(\"Image\"),\n        \"png\" => Some(\"Image\"),\n        \"bmp\" => Some(\"Image\"),\n        \"gif\" => Some(\"Image\"),\n        \"tiff\" => Some(\"Image\"),\n        \"webp\" => Some(\"Image\"),\n        \"svg\" => Some(\"Vector Image\"),\n        \"ico\" => Some(\"Icon\"),\n        \"cur\" => Some(\"Cursor\"),\n        \"dlg\" => Some(\"Dialog File\"),\n        // Audio\n        \"wav\" | \"mp3\" | \"flac\" | \"aac\" | \"m4a\" | \"ogg\" | \"opus\" | \"aiff\" | \"aif\" | \"wma\"\n        | \"mid\" | \"midi\" => Some(\"Audio\"),\n        // Fonts\n        \"ttf\" | \"otf\" | \"woff\" | \"woff2\" => Some(\"Font\"),\n        _ => None,\n    }\n}\n\n/// Display repository info. Commits are displayed in ascending order (oldest first)\n/// but the index is calculated so that the newest commit is 0 and older ones have higher numbers.\nfn info_repository(dir: &str) -> Result<(), Box<dyn Error>> {\n    let repo = match Repository::open(dir) {\n        Ok(r) => r,\n        Err(e) => {\n            if e.code() == ErrorCode::NotFound {\n                log::error!(\"No git repository in directory '{}'\", dir);\n                return Err(\"No git repository\".into());\n            } else {\n                log::error!(\"{}\", e);\n                return Err(e.into());\n            }\n        }\n    };\n\n    if let Err(e) = repo.head() {\n        if e.message()\n            .contains(\"reference 'refs/heads/master' not found\")\n            || e.message()\n                .contains(\"reference 'refs/heads/main' not found\")\n        {\n            log::error!(\"Git repository exists in '{}' but no commits - probably initialized via 'cargo new'\", dir);\n            return Err(\"Empty repository: no commits exist\".into());\n        } else {\n            log::error!(\"{}\", e);\n            return Err(e.into());\n        }\n    }\n\n    let mut revwalk = repo.revwalk()?;\n    revwalk.push_head()?;\n    revwalk.set_sorting(Sort::TIME)?;\n    let commit_ids: Vec<_> = revwalk.collect::<Result<Vec<_>, _>>()?;\n    // Reverse to get oldest first.\n    let commit_ids: Vec<_> = commit_ids.into_iter().rev().collect();\n    let total = commit_ids.len();\n    for (i, commit_id) in commit_ids.iter().enumerate() {\n        let commit = repo.find_commit(*commit_id)?;\n        let summary = commit.summary().unwrap_or(\"(no message)\");\n        let seconds = commit.time().seconds();\n        let naive = match Utc.timestamp_opt(seconds, 0) {\n            LocalResult::Single(dt) => dt.naive_utc(),\n            _ => {\n                log::error!(\"Invalid timestamp in commit\");\n                return Err(\"Invalid timestamp\".into());\n            }\n        };\n        let formatted_time = format!(\"{}\", naive.format(\"%Y-%m-%d %H:%M:%S (%a)\"));\n        let tree = commit.tree()?;\n        let diff = if commit.parent_count() > 0 {\n            let parent_tree = commit.parent(0)?.tree()?;\n            repo.diff_tree_to_tree(Some(&parent_tree), Some(&tree), None)?\n        } else {\n            repo.diff_tree_to_tree(None, Some(&tree), None)?\n        };\n        let mut file_list = Vec::new();\n        diff.foreach(\n            &mut |delta, _| {\n                match delta.status() {\n                    Delta::Added => {\n                        if let Some(path) = delta.new_file().path() {\n                            file_list.push(format!(\"{}{}{}\", GREEN, path.to_string_lossy(), RESET));\n                        }\n                    }\n                    Delta::Deleted => {\n                        if let Some(path) = delta.old_file().path() {\n                            file_list.push(format!(\"{}{}{}\", RED, path.to_string_lossy(), RESET));\n                        }\n                    }\n                    _ => {\n                        if let Some(path) = delta.new_file().path().or(delta.old_file().path()) {\n                            file_list.push(path.to_string_lossy().to_string());\n                        }\n                    }\n                }\n                true\n            },\n            None,\n            None,\n            None,\n        )?;\n        // Calculate displayed index: newest commit is 0.\n        let display_index = total - 1 - i;\n        let idx_str = format!(\"[{:03}]\", display_index);\n        log::info!(\n            \"{}{} {} | {}M:{} {} | {}F:{} {}{}\",\n            YELLOW,\n            idx_str,\n            formatted_time,\n            BLUE,\n            RESET,\n            summary,\n            BLUE,\n            RESET,\n            file_list.join(\", \"),\n            RESET\n        );\n    }\n    Ok(())\n}\n\n/// Create a .gitignore file at the repository root.\nfn create_gitignore(dir: &str, dry_run: bool) -> Result<(), Box<dyn Error>> {\n    let gitignore_path = Path::new(dir).join(\".gitignore\");\n    log::info!(\"Creating .gitignore at '{}'\", gitignore_path.display());\n    let content = generate_gitignore_content(dir)?;\n    if !dry_run {\n        fs::write(gitignore_path, content)?;\n    }\n    Ok(())\n}\n\n/// Generate the content for the .gitignore file.\nfn generate_gitignore_content(_dir: &str) -> Result<String, Box<dyn Error>> {\n    log::debug!(\"Generating .gitignore content...\");\n    // Ignore common build and virtual environment directories\n    let ignore_patterns = [\n        // Rust/Cargo\n        \"target/\",\n        // CI builds for Rust that should never be checked in\n        \"target_ci/\",\n        // Generic build outputs and environments\n        \"bin/\",\n        \"obj/\",\n        \"venv/\",\n        \".venv/\",\n        \"env/\",\n        // Common temporary/log files\n        \"*.tmp\",\n        \"*.log\",\n    ];\n    Ok(ignore_patterns.join(\"\\n\"))\n}\n\n/// Recursively check out a Git tree into the target directory.\nfn checkout_tree_to_dir(\n    repo: &Repository,\n    tree: &git2::Tree,\n    target: &Path,\n) -> Result<(), Box<dyn Error>> {\n    fs::create_dir_all(target)?;\n    for entry in tree.iter() {\n        let name = entry.name().ok_or(\"Invalid UTF-8 in filename\")?;\n        let entry_path = target.join(name);\n        match entry.kind() {\n            Some(git2::ObjectType::Tree) => {\n                let subtree = repo.find_tree(entry.id())?;\n                checkout_tree_to_dir(repo, &subtree, &entry_path)?;\n            }\n            Some(git2::ObjectType::Blob) => {\n                let blob = repo.find_blob(entry.id())?;\n                let mut file = File::create(&entry_path)?;\n                file.write_all(blob.content())?;\n            }\n            _ => {}\n        }\n    }\n    Ok(())\n}\n\n/// Create a temporary directory with the given prefix.\nfn create_temp_dir(prefix: &str) -> Result<PathBuf, Box<dyn Error>> {\n    let mut base = env::temp_dir();\n    let safe_prefix: String = prefix\n        .chars()\n        .map(|c| match c {\n            '/' | '\\\\' | ':' => '_',\n            _ => c,\n        })\n        .collect();\n    let unique = format!(\n        \"{}\",\n        std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)?\n            .as_nanos()\n    );\n    base.push(format!(\"{}.{}\", safe_prefix, unique));\n    fs::create_dir_all(&base)?;\n    Ok(base)\n}\n\n/// Create a GitHub repository using the GitHub API.\n///\n/// Tries `GITHUB_TOKEN` then `GH_TOKEN`. If neither is set, returns a helpful error\n/// suggesting to authenticate the GitHub CLI or set a token.\n/// Returns the created repository.\nfn build_repo_create_payload(\n    name: &str,\n    description: Option<&str>,\n    visibility: RepoVisibility,\n) -> serde_json::Value {\n    let mut payload = serde_json::json!({\n        \"name\": name,\n        \"description\": description.unwrap_or_default(),\n    });\n    if let Some(obj) = payload.as_object_mut() {\n        match visibility {\n            RepoVisibility::Public => {\n                obj.insert(\"private\".to_string(), serde_json::Value::Bool(false));\n            }\n            RepoVisibility::Private => {\n                obj.insert(\"private\".to_string(), serde_json::Value::Bool(true));\n            }\n            RepoVisibility::Internal => {\n                obj.insert(\n                    \"visibility\".to_string(),\n                    serde_json::Value::String(\"internal\".to_string()),\n                );\n            }\n        }\n    }\n    payload\n}\n\nasync fn gh_create_api(\n    name: &str,\n    description: Option<&str>,\n    visibility: RepoVisibility,\n) -> Result<octocrab::models::Repository, Box<dyn std::error::Error>> {\n    let token = std::env::var(\"GITHUB_TOKEN\")\n        .or_else(|_| std::env::var(\"GH_TOKEN\"))\n        .map_err(|_| {\n            \"GitHub token not found. Install and authenticate GitHub CLI (`gh auth login`) \\\nor set GITHUB_TOKEN/GH_TOKEN with repo scope.\"\n                .to_string()\n        })?;\n    let octocrab = octocrab::Octocrab::builder()\n        .personal_token(token)\n        .build()?;\n\n    // Identify the GitHub user tied to the token without exposing the token.\n    let me: serde_json::Value = octocrab.get(\"/user\", None::<&()>).await?;\n    let login = me\n        .get(\"login\")\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"(unknown)\");\n    let email = me\n        .get(\"email\")\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"(hidden or null)\");\n    println!(\n        \"GitHub auth: login '{}' (email: {}) via env:GITHUB_TOKEN\",\n        login, email\n    );\n\n    // POST to /user/repos with a JSON payload containing \"name\" and \"description\"\n    let payload = build_repo_create_payload(name, description, visibility);\n    let repo: octocrab::models::Repository = octocrab.post(\"/user/repos\", Some(&payload)).await?;\n    println!(\"Created GitHub repository: {}\", repo.html_url);\n    Ok(repo)\n}\n\n/// Locate the GitHub CLI executable if available.\n/// Returns a path to use when invoking the command.\nfn gh_cli_path() -> Option<std::path::PathBuf> {\n    use std::path::PathBuf;\n\n    // 1) Try the name via PATH first.\n    if let Ok(out) = Command::new(\"gh\").arg(\"--version\").output() {\n        if out.status.success() {\n            return Some(PathBuf::from(\"gh\"));\n        }\n    }\n\n    // 2) On Windows, try `where gh` and typical install directories.\n    #[cfg(windows)]\n    {\n        if let Ok(out) = Command::new(\"where\").arg(\"gh\").output() {\n            if out.status.success() {\n                let txt = String::from_utf8_lossy(&out.stdout);\n                if let Some(first) = txt.lines().find(|l| !l.trim().is_empty()) {\n                    let p = Path::new(first.trim());\n                    if p.exists() {\n                        return Some(p.to_path_buf());\n                    }\n                }\n            }\n        }\n\n        // Try LocalAppData user install: %LOCALAPPDATA%\\Programs\\GitHub CLI\\gh.exe\n        if let Ok(local) = std::env::var(\"LOCALAPPDATA\") {\n            let p = Path::new(&local)\n                .join(\"Programs\")\n                .join(\"GitHub CLI\")\n                .join(\"gh.exe\");\n            if p.exists() {\n                return Some(p);\n            }\n        }\n\n        // Try Program Files (x86) and Program Files locations.\n        for var in [\"ProgramFiles(x86)\", \"ProgramFiles\"] {\n            if let Ok(base) = std::env::var(var) {\n                let p = Path::new(&base).join(\"GitHub CLI\").join(\"gh.exe\");\n                if p.exists() {\n                    return Some(p);\n                }\n            }\n        }\n\n        // Fallback to the canonical Program Files path if env vars are missing.\n        let default_path = Path::new(\"C:\\\\Program Files\\\\GitHub CLI\\\\gh.exe\");\n        if default_path.exists() {\n            return Some(default_path.to_path_buf());\n        }\n    }\n\n    None\n}\n\n/// Create a GitHub repository using GitHub CLI and the system's authenticated credentials.\n/// This mirrors the existing flow by creating from the local directory, setting `origin`, and pushing.\nfn gh_create_via_cli(\n    gh_cmd: &std::path::Path,\n    directory: &str,\n    name: &str,\n    description: Option<String>,\n    visibility: RepoVisibility,\n) -> Result<(), Box<dyn std::error::Error>> {\n    let mut args = vec![\n        \"repo\", \"create\", name, \"--source\", directory, \"--remote\", \"origin\", \"--push\",\n    ];\n    // Respect user default visibility; include description if provided.\n    if let Some(desc) = description.as_deref() {\n        args.push(\"--description\");\n        args.push(desc);\n    }\n    match visibility {\n        RepoVisibility::Public => args.push(\"--public\"),\n        RepoVisibility::Private => args.push(\"--private\"),\n        RepoVisibility::Internal => args.push(\"--internal\"),\n    }\n    let status = Command::new(gh_cmd).args(&args).status()?;\n    if !status.success() {\n        return Err(\"GitHub CLI 'gh repo create' failed\".into());\n    }\n    println!(\"Created GitHub repository via GitHub CLI and pushed to 'origin'.\");\n    Ok(())\n}\n\n/// Add a remote to the local repository.\nfn add_remote(directory: &str, remote_name: &str, remote_url: &str) -> Result<(), Box<dyn Error>> {\n    let repo = Repository::open(directory)?;\n    // If the remote already exists, skip adding.\n    if repo.find_remote(remote_name).is_err() {\n        repo.remote(remote_name, remote_url)?;\n        log::info!(\"Added remote '{}' with URL '{}'\", remote_name, remote_url);\n    } else {\n        log::info!(\"Remote '{}' already exists\", remote_name);\n    }\n    Ok(())\n}\n\n/// Check if the remote branch exists.\nfn remote_branch_exists(\n    directory: &str,\n    remote: &str,\n    branch: &str,\n) -> Result<bool, Box<dyn Error>> {\n    let output = Command::new(\"git\")\n        .arg(\"-C\")\n        .arg(directory)\n        .arg(\"ls-remote\")\n        .arg(\"--heads\")\n        .arg(remote)\n        .arg(branch)\n        .output()?;\n    if output.status.success() {\n        Ok(!output.stdout.is_empty())\n    } else {\n        Ok(false)\n    }\n}\n\n/// Push local changes to the GitHub remote using the system's Git CLI.\n/// This function determines the current branch name from the repository HEAD.\nfn gh_push(directory: &str, remote: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let repo = Repository::open(directory)?;\n    let (sig, src) = resolve_signature_with_source(&repo)?;\n    let remote_url = repo\n        .find_remote(remote)\n        .ok()\n        .and_then(|r| r.url().map(|s| s.to_string()))\n        .unwrap_or_else(|| \"(unknown)\".into());\n    println!(\n        \"Using Git author: {} <{}> (source: {}) | remote: {}\",\n        sig.name().unwrap_or(\"(unknown)\"),\n        sig.email().unwrap_or(\"(unknown)\"),\n        src,\n        remote_url\n    );\n    let head = repo.head()?;\n    if !head.is_branch() {\n        return Err(\"HEAD is detached; checkout a branch before running 'mdcode gh_push'\".into());\n    }\n    let branch = head\n        .shorthand()\n        .ok_or(\"Unable to determine current branch name\")?;\n\n    // Check if the remote branch exists.\n    let branch_exists = remote_branch_exists(directory, remote, branch)?;\n\n    if branch_exists {\n        println!(\n            \"Auto-pulling changes from remote '{}' for branch '{}'\",\n            remote, branch\n        );\n        let pull_status = Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(directory)\n            .arg(\"pull\")\n            .arg(remote)\n            .arg(branch)\n            .arg(\"--no-edit\")\n            .status()?;\n        if !pull_status.success() {\n            eprintln!(\"Auto-pull failed. This may be due to merge conflicts.\");\n            println!(\"Please follow these steps to resolve merge conflicts:\");\n            println!(\"1. Run 'git status' in the repository to see the files with conflicts.\");\n            println!(\"2. Open the conflicted files and resolve the conflicts manually.\");\n            println!(\"3. After resolving, add the files using 'git add <file>' for each conflicted file.\");\n            println!(\"4. Commit the merge with 'git commit' (if needed).\");\n            println!(\"5. Finally, re-run 'mdcode p .' to push your changes.\");\n            return Err(\"Merge failed. Please resolve conflicts and try again.\".into());\n        }\n    } else {\n        println!(\"Remote branch '{}' does not exist. Skipping pull.\", branch);\n    }\n\n    println!(\n        \"Pushing local repository '{}' to remote '{}'\",\n        directory, remote\n    );\n    let push_status = if branch_exists {\n        Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(directory)\n            .arg(\"push\")\n            .arg(remote)\n            .arg(branch)\n            .status()?\n    } else {\n        // If branch doesn't exist, push and set upstream.\n        Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(directory)\n            .arg(\"push\")\n            .arg(\"-u\")\n            .arg(remote)\n            .arg(branch)\n            .status()?\n    };\n\n    if push_status.success() {\n        println!(\"Successfully pushed changes to GitHub.\");\n        Ok(())\n    } else {\n        Err(\"Failed to push changes.\".into())\n    }\n}\n\n/// Fetch changes from the remote and list commits not yet merged.\nfn gh_fetch(directory: &str, remote: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let repo = Repository::open(directory)?;\n    let (sig, src) = resolve_signature_with_source(&repo)?;\n    let remote_url = repo\n        .find_remote(remote)\n        .ok()\n        .and_then(|r| r.url().map(|s| s.to_string()))\n        .unwrap_or_else(|| \"(unknown)\".into());\n    println!(\n        \"Fetching from '{}' ({}) using Git author: {} <{}> (source: {})\",\n        remote,\n        remote_url,\n        sig.name().unwrap_or(\"(unknown)\"),\n        sig.email().unwrap_or(\"(unknown)\"),\n        src\n    );\n    let status = Command::new(\"git\")\n        .arg(\"-C\")\n        .arg(directory)\n        .arg(\"fetch\")\n        .arg(remote)\n        .status()?;\n    if !status.success() {\n        return Err(\"git fetch failed\".into());\n    }\n\n    let head = repo.head()?;\n    let branch = head.shorthand().ok_or(\"HEAD does not point to a branch\")?;\n\n    // Only show logs if the remote branch exists\n    if !remote_branch_exists(directory, remote, branch)? {\n        println!(\"Remote branch '{}/{}' does not exist.\", remote, branch);\n        return Ok(());\n    }\n\n    let output = Command::new(\"git\")\n        .arg(\"-C\")\n        .arg(directory)\n        .arg(\"log\")\n        .arg(\"--oneline\")\n        .arg(format!(\"HEAD..{}/{}\", remote, branch))\n        .output()?;\n    if !output.status.success() {\n        return Err(\"git log failed\".into());\n    }\n\n    let text = String::from_utf8_lossy(&output.stdout);\n    if text.trim().is_empty() {\n        println!(\"Local repository is up to date with remote.\");\n    } else {\n        println!(\"Commits available on remote:\");\n        print!(\"{}\", text);\n    }\n    Ok(())\n}\n\n/// Pull changes from the remote to synchronize the local repository.\nfn gh_sync(directory: &str, remote: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let repo = Repository::open(directory)?;\n    let (sig, src) = resolve_signature_with_source(&repo)?;\n    let remote_url = repo\n        .find_remote(remote)\n        .ok()\n        .and_then(|r| r.url().map(|s| s.to_string()))\n        .unwrap_or_else(|| \"(unknown)\".into());\n    println!(\n        \"Syncing with '{}' ({}) using Git author: {} <{}> (source: {})\",\n        remote,\n        remote_url,\n        sig.name().unwrap_or(\"(unknown)\"),\n        sig.email().unwrap_or(\"(unknown)\"),\n        src\n    );\n    let head = repo.head()?;\n    let branch = head.shorthand().unwrap_or(\"master\");\n\n    let exists = remote_branch_exists(directory, remote, branch)?;\n    if !exists {\n        println!(\"Remote branch '{}' does not exist. Skipping sync.\", branch);\n        return Ok(());\n    }\n\n    println!(\n        \"Pulling changes from remote '{}' for branch '{}'\",\n        remote, branch\n    );\n    let status = Command::new(\"git\")\n        .arg(\"-C\")\n        .arg(directory)\n        .arg(\"pull\")\n        .arg(remote)\n        .arg(branch)\n        .status()?;\n    if status.success() {\n        println!(\"Repository synchronized with remote.\");\n        Ok(())\n    } else {\n        Err(\"git pull failed\".into())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use std::path::Path;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_detect_file_type_source_code() {\n        // C / C++\n        assert_eq!(detect_file_type(Path::new(\"test.c\")), Some(\"C\"));\n        assert_eq!(detect_file_type(Path::new(\"test.cpp\")), Some(\"C++\"));\n        assert_eq!(detect_file_type(Path::new(\"test.cc\")), Some(\"C++\"));\n        assert_eq!(detect_file_type(Path::new(\"test.cxx\")), Some(\"C++\"));\n        assert_eq!(detect_file_type(Path::new(\"test.h\")), Some(\"C/C++ Header\"));\n        assert_eq!(detect_file_type(Path::new(\"test.hpp\")), Some(\"C++ Header\"));\n\n        // Other languages\n        assert_eq!(detect_file_type(Path::new(\"test.java\")), Some(\"Java\"));\n        assert_eq!(detect_file_type(Path::new(\"test.py\")), Some(\"Python\"));\n        assert_eq!(detect_file_type(Path::new(\"test.rb\")), Some(\"Ruby\"));\n        assert_eq!(detect_file_type(Path::new(\"test.cs\")), Some(\"C#\"));\n        assert_eq!(detect_file_type(Path::new(\"test.go\")), Some(\"Go\"));\n        assert_eq!(detect_file_type(Path::new(\"test.php\")), Some(\"PHP\"));\n        assert_eq!(detect_file_type(Path::new(\"test.rs\")), Some(\"Rust\"));\n        assert_eq!(detect_file_type(Path::new(\"test.swift\")), Some(\"Swift\"));\n        assert_eq!(detect_file_type(Path::new(\"test.kt\")), Some(\"Kotlin\"));\n        assert_eq!(detect_file_type(Path::new(\"test.kts\")), Some(\"Kotlin\"));\n        assert_eq!(detect_file_type(Path::new(\"test.scala\")), Some(\"Scala\"));\n        assert_eq!(detect_file_type(Path::new(\"test.js\")), Some(\"JavaScript\"));\n        assert_eq!(detect_file_type(Path::new(\"test.jsx\")), Some(\"JavaScript\"));\n        assert_eq!(detect_file_type(Path::new(\"test.ts\")), Some(\"TypeScript\"));\n        assert_eq!(detect_file_type(Path::new(\"test.tsx\")), Some(\"TypeScript\"));\n        assert_eq!(detect_file_type(Path::new(\"test.sh\")), Some(\"Shell Script\"));\n        assert_eq!(\n            detect_file_type(Path::new(\"test.bash\")),\n            Some(\"Shell Script\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"test.zsh\")),\n            Some(\"Shell Script\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"test.bat\")),\n            Some(\"Batch Script\")\n        );\n        assert_eq!(detect_file_type(Path::new(\"test.ps1\")), Some(\"PowerShell\"));\n    }\n\n    #[test]\n    fn test_detect_file_type_markup_and_config() {\n        // Markup and documentation\n        assert_eq!(detect_file_type(Path::new(\"index.html\")), Some(\"HTML\"));\n        assert_eq!(detect_file_type(Path::new(\"style.css\")), Some(\"CSS\"));\n        assert_eq!(detect_file_type(Path::new(\"script.scss\")), Some(\"CSS\"));\n        assert_eq!(detect_file_type(Path::new(\"doc.xml\")), Some(\"XML\"));\n        assert_eq!(detect_file_type(Path::new(\"data.json\")), Some(\"JSON\"));\n        assert_eq!(detect_file_type(Path::new(\"config.yml\")), Some(\"YAML\"));\n        assert_eq!(detect_file_type(Path::new(\"config.yaml\")), Some(\"YAML\"));\n        assert_eq!(detect_file_type(Path::new(\"Cargo.toml\")), Some(\"TOML\"));\n        assert_eq!(\n            detect_file_type(Path::new(\"README.md\")),\n            Some(\"Documentation\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"notes.txt\")),\n            Some(\"Documentation\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"manual.rst\")),\n            Some(\"Documentation\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"guide.adoc\")),\n            Some(\"Documentation\")\n        );\n\n        // Configuration / Build\n        assert_eq!(\n            detect_file_type(Path::new(\"settings.ini\")),\n            Some(\"Configuration\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"config.cfg\")),\n            Some(\"Configuration\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"app.conf\")),\n            Some(\"Configuration\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"project.sln\")),\n            Some(\"Solution File\")\n        );\n        assert_eq!(\n            detect_file_type(Path::new(\"app.csproj\")),\n            Some(\"C# Project File\")\n        );\n        assert_eq!(detect_file_type(Path::new(\"pom.xml\")), Some(\"XML\")); // Note: Maven's pom.xml is XML\n        assert_eq!(\n            detect_file_type(Path::new(\"build.gradle\")),\n            Some(\"Gradle Build File\")\n        );\n\n        // Database\n        assert_eq!(detect_file_type(Path::new(\"schema.sql\")), Some(\"SQL\"));\n    }\n\n    #[test]\n    fn test_detect_file_type_images_and_assets() {\n        // Raster images\n        assert_eq!(detect_file_type(Path::new(\"image.jpg\")), Some(\"Image\"));\n        assert_eq!(detect_file_type(Path::new(\"image.jpeg\")), Some(\"Image\"));\n        assert_eq!(detect_file_type(Path::new(\"image.png\")), Some(\"Image\"));\n        assert_eq!(detect_file_type(Path::new(\"image.bmp\")), Some(\"Image\"));\n        assert_eq!(detect_file_type(Path::new(\"image.gif\")), Some(\"Image\"));\n        assert_eq!(detect_file_type(Path::new(\"image.tiff\")), Some(\"Image\"));\n        assert_eq!(detect_file_type(Path::new(\"image.webp\")), Some(\"Image\"));\n        // Vector and icons\n        assert_eq!(\n            detect_file_type(Path::new(\"vector.svg\")),\n            Some(\"Vector Image\")\n        );\n        assert_eq!(detect_file_type(Path::new(\"icon.ico\")), Some(\"Icon\"));\n        assert_eq!(detect_file_type(Path::new(\"cursor.cur\")), Some(\"Cursor\"));\n        // Other asset\n        assert_eq!(\n            detect_file_type(Path::new(\"dialog.dlg\")),\n            Some(\"Dialog File\")\n        );\n    }\n\n    #[test]\n    fn test_generate_gitignore_content() {\n        let content = generate_gitignore_content(\".\").unwrap();\n        let expected = \"target/\\ntarget_ci/\\nbin/\\nobj/\\nvenv/\\n.venv/\\nenv/\\n*.tmp\\n*.log\";\n        assert_eq!(content, expected);\n    }\n\n    #[test]\n    fn test_new_repository_and_gitignore() {\n        if !check_git_installed() {\n            eprintln!(\"Skipping test: Git not installed\");\n            return;\n        }\n        let temp_dir = tempdir().unwrap();\n        let repo_path = temp_dir.path().join(\"repo\");\n        let repo_str = repo_path.to_str().unwrap();\n        new_repository(repo_str, false, 50).unwrap();\n        assert!(\n            Path::new(repo_str).join(\".git\").exists(),\n            \".git directory should exist\"\n        );\n        assert!(\n            Path::new(repo_str).join(\".gitignore\").exists(),\n            \".gitignore file should exist\"\n        );\n        let repo = Repository::open(repo_str).unwrap();\n        let head = repo.head().unwrap().peel_to_commit().unwrap();\n        let tree = head.tree().unwrap();\n        assert!(\n            tree.get_path(Path::new(\".gitignore\")).is_ok(),\n            \".gitignore should be part of the initial commit\"\n        );\n    }\n\n    #[test]\n    fn test_update_repository() {\n        if !check_git_installed() {\n            eprintln!(\"Skipping test: Git not installed\");\n            return;\n        }\n        let temp_dir = tempdir().unwrap();\n        let repo_path = temp_dir.path().join(\"repo\");\n        let repo_str = repo_path.to_str().unwrap();\n        new_repository(repo_str, false, 50).unwrap();\n        let file_path = repo_path.join(\"new_file.txt\");\n        fs::write(&file_path, \"Hello, mdcode!\").unwrap();\n        // Provide a commit message to avoid hanging.\n        update_repository(repo_str, false, Some(\"Test commit message\"), 50).unwrap();\n        let repo = Repository::open(repo_str).unwrap();\n        let mut revwalk = repo.revwalk().unwrap();\n        revwalk.push_head().unwrap();\n        let commits: Vec<_> = revwalk.collect();\n        assert!(\n            commits.len() >= 2,\n            \"Repository should have at least two commits\"\n        );\n        // Modify .gitignore and ensure the change is committed.\n        use std::io::Write as _;\n        let mut gitignore = std::fs::OpenOptions::new()\n            .append(true)\n            .open(repo_path.join(\".gitignore\"))\n            .unwrap();\n        writeln!(gitignore, \"# appended via test\").unwrap();\n        drop(gitignore);\n        update_repository(repo_str, false, Some(\"Update gitignore\"), 50).unwrap();\n        let head = repo.head().unwrap().peel_to_commit().unwrap();\n        let parent = head.parent(0).unwrap();\n        let diff = repo\n            .diff_tree_to_tree(\n                Some(&parent.tree().unwrap()),\n                Some(&head.tree().unwrap()),\n                None,\n            )\n            .unwrap();\n        let mut saw_gitignore = false;\n        diff.foreach(\n            &mut |delta, _| {\n                if delta.new_file().path() == Some(Path::new(\".gitignore\"))\n                    || delta.old_file().path() == Some(Path::new(\".gitignore\"))\n                {\n                    saw_gitignore = true;\n                }\n                true\n            },\n            None,\n            None,\n            None,\n        )\n        .unwrap();\n        assert!(saw_gitignore, \".gitignore changes should be committed\");\n    }\n\n    #[test]\n    fn test_update_repository_dry_run_preview() {\n        if !check_git_installed() {\n            eprintln!(\"Skipping test: Git not installed\");\n            return;\n        }\n        let temp_dir = tempdir().unwrap();\n        let repo_path = temp_dir.path().join(\"repo\");\n        let repo_str = repo_path.to_str().unwrap();\n        new_repository(repo_str, false, 50).unwrap();\n        use std::io::Write as _;\n        let mut gitignore = std::fs::OpenOptions::new()\n            .append(true)\n            .open(repo_path.join(\".gitignore\"))\n            .unwrap();\n        writeln!(gitignore, \"# dry-run change\").unwrap();\n        drop(gitignore);\n\n        update_repository(repo_str, true, None, 50).unwrap();\n\n        let repo = Repository::open(repo_str).unwrap();\n        let mut revwalk = repo.revwalk().unwrap();\n        revwalk.push_head().unwrap();\n        let commit_count = revwalk.count();\n        assert_eq!(commit_count, 1, \"dry run should not create a new commit\");\n        assert!(\n            is_dirty(repo_str).unwrap(),\n            \"dry run should leave working tree dirty\"\n        );\n    }\n\n    #[test]\n    fn test_build_repo_create_payload_visibility_flags() {\n        use serde_json::Value;\n        let public_payload =\n            build_repo_create_payload(\"repo\", Some(\"desc\"), RepoVisibility::Public);\n        assert_eq!(\n            public_payload\n                .get(\"private\")\n                .and_then(Value::as_bool)\n                .unwrap(),\n            false\n        );\n\n        let private_payload =\n            build_repo_create_payload(\"repo\", Some(\"desc\"), RepoVisibility::Private);\n        assert_eq!(\n            private_payload\n                .get(\"private\")\n                .and_then(Value::as_bool)\n                .unwrap(),\n            true\n        );\n\n        let internal_payload =\n            build_repo_create_payload(\"repo\", Some(\"desc\"), RepoVisibility::Internal);\n        assert_eq!(\n            internal_payload\n                .get(\"visibility\")\n                .and_then(Value::as_str)\n                .unwrap(),\n            \"internal\"\n        );\n    }\n\n    #[test]\n    fn test_create_temp_dir_sanitizes_windows_path() {\n        let temp_dir = create_temp_dir(\"before.C:\\\\repo\\\\subdir\").unwrap();\n        let display = temp_dir.to_string_lossy();\n        assert!(\n            !display.contains(':') && !display.contains('\\\\'),\n            \"temp dir path should be sanitized: {}\",\n            display\n        );\n        assert!(temp_dir.exists());\n        std::fs::remove_dir_all(&temp_dir).unwrap();\n    }\n\n    #[test]\n    fn test_cli_version_matches_package() {\n        use clap::CommandFactory;\n        let cmd = Cli::command();\n        let reported = cmd.get_version().unwrap();\n        assert_eq!(reported, env!(\"CARGO_PKG_VERSION\"));\n    }\n\n    #[test]\n    fn test_info_repository() {\n        if !check_git_installed() {\n            eprintln!(\"Skipping test: Git not installed\");\n            return;\n        }\n        let temp_dir = tempdir().unwrap();\n        let repo_path = temp_dir.path().join(\"repo\");\n        let repo_str = repo_path.to_str().unwrap();\n        new_repository(repo_str, false, 50).unwrap();\n        let file_path = repo_path.join(\"info_test.txt\");\n        fs::write(&file_path, \"Test info output\").unwrap();\n        update_repository(repo_str, false, Some(\"Test commit message\"), 50).unwrap();\n        info_repository(repo_str).unwrap();\n    }\n\n    #[test]\n    fn test_gh_push_errors_on_detached_head() {\n        if !check_git_installed() {\n            eprintln!(\"Skipping test: Git not installed\");\n            return;\n        }\n        let temp_dir = tempdir().unwrap();\n        let repo_path = temp_dir.path().join(\"repo\");\n        let repo_str = repo_path.to_str().unwrap();\n        new_repository(repo_str, false, 50).unwrap();\n        // Detach HEAD\n        std::process::Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(&repo_path)\n            .arg(\"checkout\")\n            .arg(\"--detach\")\n            .arg(\"HEAD\")\n            .status()\n            .unwrap();\n        let err = gh_push(repo_str, \"origin\").unwrap_err();\n        assert!(\n            err.to_string().contains(\"HEAD is detached\"),\n            \"expected detached HEAD error, got {}\",\n            err\n        );\n    }\n}\n","traces":[{"line":229,"address":[11689616,11695958,11709488],"length":1,"stats":{"Line":0}},{"line":230,"address":[11689728],"length":1,"stats":{"Line":0}},{"line":232,"address":[11689765],"length":1,"stats":{"Line":0}},{"line":233,"address":[11689835],"length":1,"stats":{"Line":0}},{"line":234,"address":[11690802,11689851,11690762],"length":1,"stats":{"Line":0}},{"line":235,"address":[11691351,11690768,11691102],"length":1,"stats":{"Line":0}},{"line":237,"address":[11689899],"length":1,"stats":{"Line":0}},{"line":238,"address":[11691392,11689915,11691432],"length":1,"stats":{"Line":0}},{"line":240,"address":[11691398,11691732],"length":1,"stats":{"Line":0}},{"line":242,"address":[11689963],"length":1,"stats":{"Line":0}},{"line":243,"address":[11691987,11692027,11689979],"length":1,"stats":{"Line":0}},{"line":244,"address":[11692327,11691993],"length":1,"stats":{"Line":0}},{"line":246,"address":[11690027],"length":1,"stats":{"Line":0}},{"line":250,"address":[11692602,11692562,11690059],"length":1,"stats":{"Line":0}},{"line":255,"address":[11692568,11692981],"length":1,"stats":{"Line":0}},{"line":257,"address":[11690195],"length":1,"stats":{"Line":0}},{"line":264,"address":[11693336,11693292,11690219],"length":1,"stats":{"Line":0}},{"line":270,"address":[11693636,11693298],"length":1,"stats":{"Line":0}},{"line":272,"address":[11693652,11694065],"length":1,"stats":{"Line":0}},{"line":273,"address":[11693856,11706366,11693801],"length":1,"stats":{"Line":0}},{"line":275,"address":[11693820,11693766],"length":1,"stats":{"Line":0}},{"line":277,"address":[11694270,11693830,11694217,11706312],"length":1,"stats":{"Line":0}},{"line":284,"address":[11694552],"length":1,"stats":{"Line":0}},{"line":285,"address":[11694588,11694560],"length":1,"stats":{"Line":0}},{"line":286,"address":[11694580],"length":1,"stats":{"Line":0}},{"line":288,"address":[11694573,11694613],"length":1,"stats":{"Line":0}},{"line":289,"address":[11694605],"length":1,"stats":{"Line":0}},{"line":291,"address":[11694598,11694666],"length":1,"stats":{"Line":0}},{"line":292,"address":[11694658],"length":1,"stats":{"Line":0}},{"line":295,"address":[11694683,11694631,11694746],"length":1,"stats":{"Line":0}},{"line":296,"address":[11694740],"length":1,"stats":{"Line":0}},{"line":297,"address":[11706258,11694791],"length":1,"stats":{"Line":0}},{"line":299,"address":[11694764,11694843],"length":1,"stats":{"Line":0}},{"line":301,"address":[11694858],"length":1,"stats":{"Line":0}},{"line":302,"address":[11695078,11695118,11694934],"length":1,"stats":{"Line":0}},{"line":304,"address":[11695092],"length":1,"stats":{"Line":0}},{"line":305,"address":[11695383],"length":1,"stats":{"Line":0}},{"line":306,"address":[11695454],"length":1,"stats":{"Line":0}},{"line":307,"address":[11695517],"length":1,"stats":{"Line":0}},{"line":311,"address":[11694979,11695971,11696025],"length":1,"stats":{"Line":0}},{"line":312,"address":[11695977,11696265,11696293],"length":1,"stats":{"Line":0}},{"line":313,"address":[11696712,11696271,11706221],"length":1,"stats":{"Line":0}},{"line":314,"address":[11697137,11706184,11697277],"length":1,"stats":{"Line":0}},{"line":315,"address":[11696964],"length":1,"stats":{"Line":0}},{"line":316,"address":[11697071],"length":1,"stats":{"Line":0}},{"line":320,"address":[11701898,11697605,11697681,11697406],"length":1,"stats":{"Line":0}},{"line":324,"address":[11701845,11697906,11698021],"length":1,"stats":{"Line":0}},{"line":326,"address":[11701794,11698278],"length":1,"stats":{"Line":0}},{"line":329,"address":[11690267],"length":1,"stats":{"Line":0}},{"line":330,"address":[11706434,11690299,11706394],"length":1,"stats":{"Line":0}},{"line":335,"address":[11706400,11706817],"length":1,"stats":{"Line":0}},{"line":337,"address":[11690347],"length":1,"stats":{"Line":0}},{"line":338,"address":[11707155,11707115,11690379],"length":1,"stats":{"Line":0}},{"line":343,"address":[11707121,11707538],"length":1,"stats":{"Line":0}},{"line":345,"address":[11690427],"length":1,"stats":{"Line":0}},{"line":346,"address":[11707836,11690459,11707876],"length":1,"stats":{"Line":0}},{"line":351,"address":[11707842,11708259],"length":1,"stats":{"Line":0}},{"line":353,"address":[11690643],"length":1,"stats":{"Line":0}},{"line":362,"address":[11690667,11708557,11708597],"length":1,"stats":{"Line":0}},{"line":364,"address":[11708563],"length":1,"stats":{"Line":0}},{"line":365,"address":[11708915],"length":1,"stats":{"Line":0}},{"line":366,"address":[11708950,11709026],"length":1,"stats":{"Line":0}},{"line":367,"address":[11709034],"length":1,"stats":{"Line":0}},{"line":368,"address":[11709042],"length":1,"stats":{"Line":0}},{"line":369,"address":[11709137],"length":1,"stats":{"Line":0}},{"line":370,"address":[11709141],"length":1,"stats":{"Line":0}},{"line":371,"address":[11709145],"length":1,"stats":{"Line":0}},{"line":375,"address":[11691305],"length":1,"stats":{"Line":0}},{"line":378,"address":[11709504,11710021,11710027],"length":1,"stats":{"Line":0}},{"line":381,"address":[11709511],"length":1,"stats":{"Line":0}},{"line":382,"address":[11709535],"length":1,"stats":{"Line":0}},{"line":383,"address":[12098596],"length":1,"stats":{"Line":0}},{"line":384,"address":[12098766],"length":1,"stats":{"Line":0}},{"line":386,"address":[12098636],"length":1,"stats":{"Line":0}},{"line":389,"address":[11709593],"length":1,"stats":{"Line":0}},{"line":392,"address":[11709643],"length":1,"stats":{"Line":0}},{"line":393,"address":[11709852,11709727],"length":1,"stats":{"Line":0}},{"line":394,"address":[11710003],"length":1,"stats":{"Line":0}},{"line":399,"address":[11711359,11711346,11710048],"length":1,"stats":{"Line":1}},{"line":400,"address":[11710107],"length":1,"stats":{"Line":1}},{"line":401,"address":[11710156,11710224],"length":1,"stats":{"Line":2}},{"line":402,"address":[11710250],"length":1,"stats":{"Line":0}},{"line":404,"address":[11711354,11710318,11710341],"length":1,"stats":{"Line":2}},{"line":405,"address":[11710594,11711352,11710515],"length":1,"stats":{"Line":2}},{"line":406,"address":[11710842,11710923],"length":1,"stats":{"Line":2}},{"line":407,"address":[11710978,11711075],"length":1,"stats":{"Line":4}},{"line":408,"address":[11711183],"length":1,"stats":{"Line":1}},{"line":411,"address":[11711017],"length":1,"stats":{"Line":0}},{"line":417,"address":[11711376,11716067,11716958],"length":1,"stats":{"Line":1}},{"line":418,"address":[11711415],"length":1,"stats":{"Line":1}},{"line":420,"address":[11711687,11711608],"length":1,"stats":{"Line":2}},{"line":421,"address":[11716945],"length":1,"stats":{"Line":0}},{"line":425,"address":[11711796],"length":1,"stats":{"Line":1}},{"line":426,"address":[11711815],"length":1,"stats":{"Line":1}},{"line":431,"address":[11712018],"length":1,"stats":{"Line":1}},{"line":432,"address":[11716916,11712034],"length":1,"stats":{"Line":1}},{"line":433,"address":[11712218],"length":1,"stats":{"Line":1}},{"line":434,"address":[11712226,11712313],"length":1,"stats":{"Line":2}},{"line":435,"address":[11712517,11712465],"length":1,"stats":{"Line":2}},{"line":436,"address":[11712745],"length":1,"stats":{"Line":1}},{"line":437,"address":[11712534],"length":1,"stats":{"Line":1}},{"line":447,"address":[11712775],"length":1,"stats":{"Line":1}},{"line":451,"address":[11712491],"length":1,"stats":{"Line":1}},{"line":452,"address":[11712796],"length":1,"stats":{"Line":1}},{"line":456,"address":[11712809,11712882,11716892],"length":1,"stats":{"Line":2}},{"line":457,"address":[11713052,11716865],"length":1,"stats":{"Line":1}},{"line":459,"address":[11716976,11717688],"length":1,"stats":{"Line":1}},{"line":461,"address":[11717006,11717068],"length":1,"stats":{"Line":2}},{"line":462,"address":[11717091],"length":1,"stats":{"Line":1}},{"line":463,"address":[11717108,11717188],"length":1,"stats":{"Line":2}},{"line":464,"address":[11717662,11717254,11717376,11717570],"length":1,"stats":{"Line":4}},{"line":465,"address":[11717507],"length":1,"stats":{"Line":0}},{"line":466,"address":[11717575,11717535],"length":1,"stats":{"Line":0}},{"line":468,"address":[11717337,11717601],"length":1,"stats":{"Line":2}},{"line":469,"address":[11717667,11717627],"length":1,"stats":{"Line":2}},{"line":472,"address":[11717203],"length":1,"stats":{"Line":2}},{"line":475,"address":[11713511],"length":1,"stats":{"Line":1}},{"line":476,"address":[11713706,11713845],"length":1,"stats":{"Line":2}},{"line":477,"address":[11714055],"length":1,"stats":{"Line":1}},{"line":478,"address":[11713862],"length":1,"stats":{"Line":1}},{"line":491,"address":[11714132],"length":1,"stats":{"Line":1}},{"line":492,"address":[11714089],"length":1,"stats":{"Line":1}},{"line":500,"address":[11716849],"length":1,"stats":{"Line":0}},{"line":503,"address":[11714153,11714224],"length":1,"stats":{"Line":4}},{"line":504,"address":[11714307],"length":1,"stats":{"Line":1}},{"line":505,"address":[11714448,11714381],"length":1,"stats":{"Line":2}},{"line":506,"address":[11714651,11714549,11714478],"length":1,"stats":{"Line":3}},{"line":507,"address":[11714667,11714750],"length":1,"stats":{"Line":2}},{"line":508,"address":[11714808],"length":1,"stats":{"Line":2}},{"line":509,"address":[11714951,11715018,11714903],"length":1,"stats":{"Line":6}},{"line":510,"address":[11715066],"length":1,"stats":{"Line":2}},{"line":511,"address":[11715117,11715193],"length":1,"stats":{"Line":4}},{"line":521,"address":[11715533],"length":1,"stats":{"Line":2}},{"line":526,"address":[11716150],"length":1,"stats":{"Line":0}},{"line":531,"address":[11716401],"length":1,"stats":{"Line":0}},{"line":537,"address":[11716585],"length":1,"stats":{"Line":0}},{"line":541,"address":[11713740],"length":1,"stats":{"Line":0}},{"line":545,"address":[11718301,11718295,11717712],"length":1,"stats":{"Line":1}},{"line":546,"address":[11717769],"length":1,"stats":{"Line":1}},{"line":547,"address":[11717810],"length":1,"stats":{"Line":1}},{"line":548,"address":[11718014,11718062],"length":1,"stats":{"Line":2}},{"line":549,"address":[11718162],"length":1,"stats":{"Line":1}},{"line":554,"address":[11718320,11720039,11725903],"length":1,"stats":{"Line":1}},{"line":564,"address":[11718486,11725697,11718590],"length":1,"stats":{"Line":2}},{"line":566,"address":[11718902,11718758,11719142],"length":1,"stats":{"Line":2}},{"line":567,"address":[11719088],"length":1,"stats":{"Line":1}},{"line":568,"address":[11719030],"length":1,"stats":{"Line":1}},{"line":573,"address":[11719259,11719168,11718801],"length":1,"stats":{"Line":3}},{"line":574,"address":[11719211],"length":1,"stats":{"Line":1}},{"line":575,"address":[11719261,11719342,11725648,11719747],"length":1,"stats":{"Line":0}},{"line":576,"address":[11719752,11719568,11719693],"length":1,"stats":{"Line":0}},{"line":577,"address":[11719699],"length":1,"stats":{"Line":0}},{"line":579,"address":[11719613,11720045],"length":1,"stats":{"Line":0}},{"line":580,"address":[11725611,11720064],"length":1,"stats":{"Line":0}},{"line":581,"address":[11720257],"length":1,"stats":{"Line":0}},{"line":582,"address":[11720335,11720264,11725557],"length":1,"stats":{"Line":0}},{"line":583,"address":[11720548],"length":1,"stats":{"Line":0}},{"line":587,"address":[11719300,11725523,11720735],"length":1,"stats":{"Line":2}},{"line":589,"address":[12099073,12099056],"length":1,"stats":{"Line":3}},{"line":592,"address":[11721132,11721200],"length":1,"stats":{"Line":2}},{"line":593,"address":[11721308,11721391],"length":1,"stats":{"Line":2}},{"line":594,"address":[11721556,11721523],"length":1,"stats":{"Line":1}},{"line":595,"address":[11721743,11721562],"length":1,"stats":{"Line":0}},{"line":599,"address":[11721689],"length":1,"stats":{"Line":0}},{"line":602,"address":[11721536],"length":1,"stats":{"Line":1}},{"line":603,"address":[11724503],"length":1,"stats":{"Line":0}},{"line":610,"address":[11724417],"length":1,"stats":{"Line":1}},{"line":611,"address":[11724973],"length":1,"stats":{"Line":0}},{"line":618,"address":[11724956],"length":1,"stats":{"Line":1}},{"line":622,"address":[11721791,11721862],"length":1,"stats":{"Line":0}},{"line":623,"address":[11722291,11722324],"length":1,"stats":{"Line":0}},{"line":624,"address":[11722555,11722330,11722401],"length":1,"stats":{"Line":0}},{"line":628,"address":[11722501],"length":1,"stats":{"Line":0}},{"line":630,"address":[11722304],"length":1,"stats":{"Line":0}},{"line":632,"address":[11722624],"length":1,"stats":{"Line":0}},{"line":634,"address":[11722680,11722593,11724359],"length":1,"stats":{"Line":0}},{"line":635,"address":[11722905],"length":1,"stats":{"Line":0}},{"line":636,"address":[11722932,11723017],"length":1,"stats":{"Line":0}},{"line":638,"address":[11722974,11723038],"length":1,"stats":{"Line":0}},{"line":640,"address":[11723114],"length":1,"stats":{"Line":0}},{"line":642,"address":[11723244,11723154,11723320,11724322],"length":1,"stats":{"Line":0}},{"line":643,"address":[11723385,11723221,11723288],"length":1,"stats":{"Line":0}},{"line":644,"address":[11724268,11723526,11723404,11723745,11723602,11723687],"length":1,"stats":{"Line":0}},{"line":646,"address":[11723542],"length":1,"stats":{"Line":0}},{"line":648,"address":[11723618],"length":1,"stats":{"Line":0}},{"line":649,"address":[11723639],"length":1,"stats":{"Line":0}},{"line":651,"address":[11723820],"length":1,"stats":{"Line":0}},{"line":652,"address":[11723938,11723841],"length":1,"stats":{"Line":0}},{"line":654,"address":[11723959,11723885],"length":1,"stats":{"Line":0}},{"line":657,"address":[11723120],"length":1,"stats":{"Line":0}},{"line":978,"address":[11725936],"length":1,"stats":{"Line":4}},{"line":979,"address":[11725956],"length":1,"stats":{"Line":4}},{"line":980,"address":[11725967],"length":1,"stats":{"Line":12}},{"line":981,"address":[12099395,12099438],"length":1,"stats":{"Line":7}},{"line":982,"address":[12099481],"length":1,"stats":{"Line":1}},{"line":983,"address":[12099555],"length":1,"stats":{"Line":3}},{"line":985,"address":[12099660],"length":1,"stats":{"Line":1}},{"line":986,"address":[12099428],"length":1,"stats":{"Line":0}},{"line":991,"address":[11725984,11727372,11727378],"length":1,"stats":{"Line":2}},{"line":992,"address":[11726041],"length":1,"stats":{"Line":1}},{"line":993,"address":[11726188,11726058],"length":1,"stats":{"Line":0}},{"line":994,"address":[11726143],"length":1,"stats":{"Line":0}},{"line":997,"address":[11726097],"length":1,"stats":{"Line":4}},{"line":998,"address":[11726586,11726474],"length":1,"stats":{"Line":0}},{"line":999,"address":[11726602,11726681],"length":1,"stats":{"Line":0}},{"line":1000,"address":[11726875,11726978],"length":1,"stats":{"Line":0}},{"line":1001,"address":[11726933,11727278],"length":1,"stats":{"Line":0}},{"line":1006,"address":[11726384,11727424],"length":1,"stats":{"Line":6}},{"line":1007,"address":[11727521],"length":1,"stats":{"Line":4}},{"line":1008,"address":[11727856,11727753],"length":1,"stats":{"Line":3}},{"line":1009,"address":[11727988,11727896],"length":1,"stats":{"Line":5}},{"line":1010,"address":[11728203,11728090],"length":1,"stats":{"Line":3}},{"line":1013,"address":[11728221,11728160],"length":1,"stats":{"Line":5}},{"line":1014,"address":[11728342,11728248,11728320],"length":1,"stats":{"Line":10}},{"line":1015,"address":[11728333],"length":1,"stats":{"Line":2}},{"line":1016,"address":[11728626],"length":1,"stats":{"Line":5}},{"line":1019,"address":[11728300],"length":1,"stats":{"Line":1}},{"line":1020,"address":[11728852],"length":1,"stats":{"Line":0}},{"line":1023,"address":[11728839],"length":1,"stats":{"Line":4}},{"line":1024,"address":[11732938,11729185],"length":1,"stats":{"Line":0}},{"line":1026,"address":[11732863,11729203,11729146],"length":1,"stats":{"Line":3}},{"line":1028,"address":[11729460,11729364,11729510],"length":1,"stats":{"Line":4}},{"line":1029,"address":[11732829,11729466,11729759],"length":1,"stats":{"Line":4}},{"line":1030,"address":[11729910,11732795],"length":1,"stats":{"Line":3}},{"line":1032,"address":[11732761,11730138],"length":1,"stats":{"Line":3}},{"line":1033,"address":[11730322,11730393,11732705],"length":1,"stats":{"Line":5}},{"line":1034,"address":[11730530,11732671],"length":1,"stats":{"Line":4}},{"line":1035,"address":[11732637,11730720],"length":1,"stats":{"Line":2}},{"line":1036,"address":[11732584,11730958,11731025],"length":1,"stats":{"Line":4}},{"line":1037,"address":[11731781,11731448,11731244,11731340],"length":1,"stats":{"Line":11}},{"line":1043,"address":[11732495,11731346,11732129,11732205],"length":1,"stats":{"Line":6}},{"line":1051,"address":[11732284],"length":1,"stats":{"Line":1}},{"line":1054,"address":[11733141],"length":1,"stats":{"Line":0}},{"line":1064,"address":[11733748,11732964,11733785],"length":1,"stats":{"Line":11}},{"line":1074,"address":[11733754],"length":1,"stats":{"Line":1}},{"line":1079,"address":[11745597,11734416,11736584],"length":1,"stats":{"Line":2}},{"line":1085,"address":[11734504],"length":1,"stats":{"Line":1}},{"line":1086,"address":[11734618],"length":1,"stats":{"Line":1}},{"line":1088,"address":[11734570,11745724,11745679],"length":1,"stats":{"Line":0}},{"line":1094,"address":[11746132,11745685],"length":1,"stats":{"Line":0}},{"line":1097,"address":[11734694,11734822,11734790],"length":1,"stats":{"Line":4}},{"line":1098,"address":[11745579,11734812,11735071],"length":1,"stats":{"Line":3}},{"line":1099,"address":[11735285,11745526,11735198],"length":1,"stats":{"Line":3}},{"line":1100,"address":[11735434,11735525,11745473],"length":1,"stats":{"Line":3}},{"line":1101,"address":[11735698,11745417,11735800],"length":1,"stats":{"Line":2}},{"line":1102,"address":[11735981],"length":1,"stats":{"Line":1}},{"line":1103,"address":[11736127,11736267,11736325,11735985,11736549],"length":1,"stats":{"Line":4}},{"line":1105,"address":[11736143],"length":1,"stats":{"Line":1}},{"line":1109,"address":[11736406],"length":1,"stats":{"Line":1}},{"line":1110,"address":[11736437],"length":1,"stats":{"Line":0}},{"line":1114,"address":[11736023],"length":1,"stats":{"Line":1}},{"line":1115,"address":[11736617],"length":1,"stats":{"Line":1}},{"line":1116,"address":[11743083],"length":1,"stats":{"Line":1}},{"line":1117,"address":[11745383,11743151],"length":1,"stats":{"Line":1}},{"line":1118,"address":[11743351],"length":1,"stats":{"Line":1}},{"line":1119,"address":[11745305,11743430,11743635,11743539],"length":1,"stats":{"Line":2}},{"line":1120,"address":[11743422],"length":1,"stats":{"Line":2}},{"line":1121,"address":[12099858],"length":1,"stats":{"Line":1}},{"line":1123,"address":[12100067,12100228],"length":1,"stats":{"Line":0}},{"line":1124,"address":[12100285,12100254,12100362],"length":1,"stats":{"Line":0}},{"line":1127,"address":[12100275],"length":1,"stats":{"Line":0}},{"line":1133,"address":[12100137,12100656],"length":1,"stats":{"Line":0}},{"line":1134,"address":[12100688,12100719],"length":1,"stats":{"Line":0}},{"line":1137,"address":[12100709],"length":1,"stats":{"Line":0}},{"line":1143,"address":[12099907,12101059],"length":1,"stats":{"Line":2}},{"line":1144,"address":[12101091],"length":1,"stats":{"Line":1}},{"line":1154,"address":[11743676],"length":1,"stats":{"Line":1}},{"line":1155,"address":[11745054,11743760,11745074],"length":1,"stats":{"Line":0}},{"line":1156,"address":[11745060],"length":1,"stats":{"Line":0}},{"line":1158,"address":[11743815,11743861,11743715],"length":1,"stats":{"Line":3}},{"line":1159,"address":[11743821,11744421],"length":1,"stats":{"Line":1}},{"line":1160,"address":[11744453,11744503],"length":1,"stats":{"Line":0}},{"line":1162,"address":[11744472,11744550],"length":1,"stats":{"Line":2}},{"line":1164,"address":[11744505,11744766,11744603,11744643],"length":1,"stats":{"Line":3}},{"line":1169,"address":[11744609],"length":1,"stats":{"Line":1}},{"line":1172,"address":[11743062,11736590,11736655],"length":1,"stats":{"Line":2}},{"line":1173,"address":[11736796,11736867,11743025],"length":1,"stats":{"Line":2}},{"line":1174,"address":[11737004,11742988],"length":1,"stats":{"Line":1}},{"line":1175,"address":[11737224],"length":1,"stats":{"Line":1}},{"line":1176,"address":[11742739,11737363,11742719],"length":1,"stats":{"Line":0}},{"line":1177,"address":[11742725],"length":1,"stats":{"Line":0}},{"line":1179,"address":[11737427,11742694,11737298],"length":1,"stats":{"Line":2}},{"line":1180,"address":[11737676,11742638,11737568],"length":1,"stats":{"Line":2}},{"line":1181,"address":[11737817],"length":1,"stats":{"Line":1}},{"line":1182,"address":[11738101,11742563,11737896,11738005],"length":1,"stats":{"Line":3}},{"line":1183,"address":[11737888],"length":1,"stats":{"Line":3}},{"line":1184,"address":[12101282],"length":1,"stats":{"Line":1}},{"line":1186,"address":[12101652,12101491],"length":1,"stats":{"Line":3}},{"line":1187,"address":[12101678,12101786],"length":1,"stats":{"Line":2}},{"line":1191,"address":[12102080,12101561],"length":1,"stats":{"Line":0}},{"line":1192,"address":[12102112],"length":1,"stats":{"Line":0}},{"line":1196,"address":[12102483,12101331],"length":1,"stats":{"Line":2}},{"line":1197,"address":[12102515],"length":1,"stats":{"Line":1}},{"line":1207,"address":[11738142,11738240],"length":1,"stats":{"Line":2}},{"line":1210,"address":[11738200,11738800],"length":1,"stats":{"Line":2}},{"line":1211,"address":[11738832,11738877],"length":1,"stats":{"Line":2}},{"line":1213,"address":[11738927,11738851],"length":1,"stats":{"Line":0}},{"line":1214,"address":[11738946,11742529],"length":1,"stats":{"Line":0}},{"line":1215,"address":[11739139],"length":1,"stats":{"Line":0}},{"line":1216,"address":[11739217,11739146,11742478],"length":1,"stats":{"Line":0}},{"line":1217,"address":[11739430],"length":1,"stats":{"Line":0}},{"line":1218,"address":[11739566,11739695],"length":1,"stats":{"Line":0}},{"line":1220,"address":[11739613,11739543],"length":1,"stats":{"Line":0}},{"line":1224,"address":[11738879,11739748,11739780],"length":1,"stats":{"Line":3}},{"line":1225,"address":[11740212,11739770,11742425],"length":1,"stats":{"Line":2}},{"line":1226,"address":[11740431,11740897,11740527,11740567],"length":1,"stats":{"Line":3}},{"line":1232,"address":[11741445,11742336,11741261],"length":1,"stats":{"Line":2}},{"line":1236,"address":[11740541],"length":1,"stats":{"Line":1}},{"line":1238,"address":[11741253],"length":1,"stats":{"Line":2}},{"line":1240,"address":[11741686],"length":1,"stats":{"Line":0}},{"line":1246,"address":[11741574],"length":1,"stats":{"Line":2}},{"line":1250,"address":[11748696,11748746,11746240],"length":1,"stats":{"Line":6}},{"line":1251,"address":[11746279,11746407],"length":1,"stats":{"Line":7}},{"line":1252,"address":[11746316],"length":1,"stats":{"Line":6}},{"line":1256,"address":[11746328],"length":1,"stats":{"Line":6}},{"line":1257,"address":[11746704,11746361],"length":1,"stats":{"Line":12}},{"line":1258,"address":[11746790],"length":1,"stats":{"Line":6}},{"line":1260,"address":[11747169,11746857,11747269],"length":1,"stats":{"Line":15}},{"line":1261,"address":[11746928],"length":1,"stats":{"Line":6}},{"line":1262,"address":[11747006],"length":1,"stats":{"Line":6}},{"line":1263,"address":[11747038],"length":1,"stats":{"Line":6}},{"line":1264,"address":[11747070],"length":1,"stats":{"Line":6}},{"line":1265,"address":[11747102],"length":1,"stats":{"Line":6}},{"line":1266,"address":[11747134],"length":1,"stats":{"Line":6}},{"line":1268,"address":[11747323],"length":1,"stats":{"Line":1}},{"line":1269,"address":[11747815],"length":1,"stats":{"Line":0}},{"line":1272,"address":[11748122,11748039],"length":1,"stats":{"Line":0}},{"line":1273,"address":[11748154],"length":1,"stats":{"Line":0}},{"line":1276,"address":[11748175,11748244],"length":1,"stats":{"Line":0}},{"line":1277,"address":[11748446,11748366],"length":1,"stats":{"Line":0}},{"line":1279,"address":[11748317,11748252],"length":1,"stats":{"Line":0}},{"line":1286,"address":[11748566,11748467,11748279],"length":1,"stats":{"Line":0}},{"line":1287,"address":[11748568,11748531],"length":1,"stats":{"Line":0}},{"line":1290,"address":[11747512,11747398],"length":1,"stats":{"Line":6}},{"line":1291,"address":[11747464],"length":1,"stats":{"Line":2}},{"line":1295,"address":[11748768,11752362,11752062],"length":1,"stats":{"Line":4}},{"line":1296,"address":[11748928,11748815],"length":1,"stats":{"Line":8}},{"line":1297,"address":[11748860],"length":1,"stats":{"Line":4}},{"line":1298,"address":[11748885],"length":1,"stats":{"Line":4}},{"line":1299,"address":[11748897,11749216],"length":1,"stats":{"Line":8}},{"line":1301,"address":[11749247],"length":1,"stats":{"Line":4}},{"line":1302,"address":[11749282,11749385],"length":1,"stats":{"Line":8}},{"line":1303,"address":[11749471],"length":1,"stats":{"Line":4}},{"line":1305,"address":[11749852,11749540,11749952],"length":1,"stats":{"Line":12}},{"line":1306,"address":[11749611],"length":1,"stats":{"Line":4}},{"line":1307,"address":[11749689],"length":1,"stats":{"Line":4}},{"line":1308,"address":[11749721],"length":1,"stats":{"Line":4}},{"line":1309,"address":[11749753],"length":1,"stats":{"Line":4}},{"line":1310,"address":[11749785],"length":1,"stats":{"Line":4}},{"line":1311,"address":[11749817],"length":1,"stats":{"Line":4}},{"line":1313,"address":[11750006],"length":1,"stats":{"Line":4}},{"line":1314,"address":[11750628],"length":1,"stats":{"Line":4}},{"line":1317,"address":[11750852,11750947],"length":1,"stats":{"Line":8}},{"line":1318,"address":[11750985],"length":1,"stats":{"Line":4}},{"line":1321,"address":[11751012,11751069],"length":1,"stats":{"Line":8}},{"line":1322,"address":[11751136],"length":1,"stats":{"Line":2}},{"line":1323,"address":[11751267,11751207],"length":1,"stats":{"Line":4}},{"line":1327,"address":[11752185,11751240,11751326],"length":1,"stats":{"Line":5}},{"line":1328,"address":[11751394,11751511],"length":1,"stats":{"Line":4}},{"line":1329,"address":[11751587,11751518],"length":1,"stats":{"Line":3}},{"line":1330,"address":[11751752],"length":1,"stats":{"Line":0}},{"line":1338,"address":[11752103],"length":1,"stats":{"Line":1}},{"line":1339,"address":[11752190,11752152],"length":1,"stats":{"Line":2}},{"line":1343,"address":[11750280,11750081],"length":1,"stats":{"Line":3}},{"line":1344,"address":[11750151],"length":1,"stats":{"Line":2}},{"line":1348,"address":[11752400,11754101,11754093],"length":1,"stats":{"Line":3}},{"line":1349,"address":[11752506],"length":1,"stats":{"Line":3}},{"line":1350,"address":[11754099,11752699,11752786],"length":1,"stats":{"Line":6}},{"line":1351,"address":[11753018,11752935],"length":1,"stats":{"Line":6}},{"line":1352,"address":[11753136],"length":1,"stats":{"Line":3}},{"line":1353,"address":[11753743],"length":1,"stats":{"Line":3}},{"line":1354,"address":[11753912],"length":1,"stats":{"Line":3}},{"line":1357,"address":[11753714,11753145],"length":1,"stats":{"Line":3}},{"line":1358,"address":[11753402,11753301],"length":1,"stats":{"Line":6}},{"line":1359,"address":[11753369],"length":1,"stats":{"Line":3}},{"line":1363,"address":[11754128,11754542,11754600],"length":1,"stats":{"Line":7}},{"line":1364,"address":[11754300,11754245,11754135],"length":1,"stats":{"Line":7}},{"line":1365,"address":[11754365,11754421],"length":1,"stats":{"Line":3}},{"line":1367,"address":[11754295],"length":1,"stats":{"Line":0}},{"line":1372,"address":[11754624,11755602,11755608],"length":1,"stats":{"Line":1}},{"line":1373,"address":[11755637,11754649],"length":1,"stats":{"Line":2}},{"line":1374,"address":[11755373,11755590],"length":1,"stats":{"Line":1}},{"line":1375,"address":[11755558],"length":1,"stats":{"Line":2}},{"line":1379,"address":[11756749,11756796,11755680],"length":1,"stats":{"Line":0}},{"line":1380,"address":[11755721],"length":1,"stats":{"Line":0}},{"line":1381,"address":[11755962,11756771,11755897],"length":1,"stats":{"Line":0}},{"line":1382,"address":[11756088,11756769],"length":1,"stats":{"Line":0}},{"line":1383,"address":[11756243,11756755],"length":1,"stats":{"Line":0}},{"line":1384,"address":[11756461,11756538],"length":1,"stats":{"Line":0}},{"line":1385,"address":[11756658,11756726,11756583],"length":1,"stats":{"Line":0}},{"line":1386,"address":[12102768,12102769],"length":1,"stats":{"Line":0}},{"line":1388,"address":[11756627,11756543],"length":1,"stats":{"Line":0}},{"line":1393,"address":[11757889,11758133,11756832],"length":1,"stats":{"Line":1}},{"line":1396,"address":[11757048,11757229,11756871],"length":1,"stats":{"Line":2}},{"line":1397,"address":[11756935],"length":1,"stats":{"Line":3}},{"line":1398,"address":[11756980],"length":1,"stats":{"Line":5}},{"line":1400,"address":[11757772],"length":1,"stats":{"Line":0}},{"line":1401,"address":[11757895,11757438,11757331],"length":1,"stats":{"Line":0}},{"line":1402,"address":[11757682],"length":1,"stats":{"Line":0}},{"line":1405,"address":[11758686,11758505],"length":1,"stats":{"Line":5}},{"line":1406,"address":[11758368],"length":1,"stats":{"Line":4}},{"line":1407,"address":[11758413],"length":1,"stats":{"Line":1}},{"line":1409,"address":[11759211],"length":1,"stats":{"Line":0}},{"line":1410,"address":[11758889,11759328,11758788],"length":1,"stats":{"Line":0}},{"line":1411,"address":[11759121],"length":1,"stats":{"Line":0}},{"line":1415,"address":[11759922,11759799],"length":1,"stats":{"Line":6}},{"line":1416,"address":[11759938,11760021],"length":1,"stats":{"Line":6}},{"line":1417,"address":[11760048,11760131],"length":1,"stats":{"Line":6}},{"line":1418,"address":[11760438,11760158],"length":1,"stats":{"Line":6}},{"line":1419,"address":[11760931],"length":1,"stats":{"Line":5}},{"line":1420,"address":[11760615,11761048,11760526],"length":1,"stats":{"Line":7}},{"line":1421,"address":[11760841],"length":1,"stats":{"Line":1}},{"line":1425,"address":[11761634,11761537],"length":1,"stats":{"Line":0}},{"line":1426,"address":[11761650,11761733],"length":1,"stats":{"Line":0}},{"line":1427,"address":[11761760,11761843],"length":1,"stats":{"Line":0}},{"line":1428,"address":[11762150,11761870],"length":1,"stats":{"Line":0}},{"line":1429,"address":[11762760,11762238,11762327],"length":1,"stats":{"Line":0}},{"line":1433,"address":[11763578],"length":1,"stats":{"Line":0}},{"line":1434,"address":[11763249],"length":1,"stats":{"Line":0}},{"line":1435,"address":[11763488],"length":1,"stats":{"Line":0}},{"line":1440,"address":[11767423,11763808,11767208],"length":1,"stats":{"Line":0}},{"line":1445,"address":[11763879,11764018,11763926],"length":1,"stats":{"Line":0}},{"line":1446,"address":[11763905,11763986,11764059],"length":1,"stats":{"Line":0}},{"line":1449,"address":[11764076,11764344,11764410],"length":1,"stats":{"Line":0}},{"line":1451,"address":[11764220],"length":1,"stats":{"Line":0}},{"line":1455,"address":[11764462],"length":1,"stats":{"Line":0}},{"line":1456,"address":[11764479],"length":1,"stats":{"Line":0}},{"line":1460,"address":[11764531],"length":1,"stats":{"Line":0}},{"line":1461,"address":[11764646],"length":1,"stats":{"Line":0}},{"line":1462,"address":[],"length":0,"stats":{"Line":0}},{"line":1464,"address":[11765065,11764612,11765133],"length":1,"stats":{"Line":0}},{"line":1466,"address":[11764886],"length":1,"stats":{"Line":0}},{"line":1471,"address":[11765341],"length":1,"stats":{"Line":0}},{"line":1472,"address":[11765376,11765471],"length":1,"stats":{"Line":0}},{"line":1474,"address":[11765510,11765418],"length":1,"stats":{"Line":0}},{"line":1475,"address":[11765748,11765829,11765529],"length":1,"stats":{"Line":0}},{"line":1477,"address":[11765635],"length":1,"stats":{"Line":0}},{"line":1478,"address":[12102880,12102900],"length":1,"stats":{"Line":0}},{"line":1479,"address":[12102960,12102974],"length":1,"stats":{"Line":0}},{"line":1481,"address":[11765894],"length":1,"stats":{"Line":0}},{"line":1482,"address":[11766108,11766029],"length":1,"stats":{"Line":0}},{"line":1489,"address":[11766440,11766523],"length":1,"stats":{"Line":0}},{"line":1490,"address":[11766610,11766675,11767214],"length":1,"stats":{"Line":0}},{"line":1491,"address":[11766879,11766808],"length":1,"stats":{"Line":0}},{"line":1492,"address":[11767052],"length":1,"stats":{"Line":0}},{"line":1493,"address":[11767418,11767170,11767216,11766835,11766629,11767132],"length":1,"stats":{"Line":0}},{"line":1495,"address":[12103008,12103009],"length":1,"stats":{"Line":0}},{"line":1497,"address":[11767331,11767411],"length":1,"stats":{"Line":0}},{"line":1502,"address":[11781032,11767680,11771681],"length":1,"stats":{"Line":0}},{"line":1503,"address":[11767769],"length":1,"stats":{"Line":0}},{"line":1504,"address":[11768010,11768064,11768179],"length":1,"stats":{"Line":0}},{"line":1505,"address":[11768325,11768041,11768271],"length":1,"stats":{"Line":0}},{"line":1507,"address":[11768459,11768221,11768629],"length":1,"stats":{"Line":0}},{"line":1509,"address":[11768705,11768296,11768671],"length":1,"stats":{"Line":0}},{"line":1510,"address":[11768694],"length":1,"stats":{"Line":0}},{"line":1512,"address":[11768817,11768966,11768718,11768685,11768896,11769063],"length":1,"stats":{"Line":0}},{"line":1514,"address":[11768934,11768873],"length":1,"stats":{"Line":0}},{"line":1516,"address":[11769017,11769084],"length":1,"stats":{"Line":0}},{"line":1517,"address":[11769163],"length":1,"stats":{"Line":0}},{"line":1519,"address":[11769115,11780607,11780562],"length":1,"stats":{"Line":0}},{"line":1520,"address":[11780568,11780945],"length":1,"stats":{"Line":0}},{"line":1524,"address":[11769300,11780477,11768583],"length":1,"stats":{"Line":0}},{"line":1525,"address":[11769441,11769512],"length":1,"stats":{"Line":0}},{"line":1526,"address":[11769688,11769586],"length":1,"stats":{"Line":0}},{"line":1527,"address":[11780421,11769643],"length":1,"stats":{"Line":0}},{"line":1529,"address":[11769809,11769896],"length":1,"stats":{"Line":0}},{"line":1530,"address":[11770047,11770138,11780346],"length":1,"stats":{"Line":0}},{"line":1531,"address":[11770373],"length":1,"stats":{"Line":0}},{"line":1532,"address":[11770532,11770385],"length":1,"stats":{"Line":0}},{"line":1534,"address":[11770784,11770813,11770408],"length":1,"stats":{"Line":0}},{"line":1536,"address":[11771569],"length":1,"stats":{"Line":0}},{"line":1538,"address":[11771363],"length":1,"stats":{"Line":0}},{"line":1539,"address":[11771122,11778957],"length":1,"stats":{"Line":0}},{"line":1540,"address":[11771750,11771695],"length":1,"stats":{"Line":0}},{"line":1541,"address":[11778743,11775374,11775496,11775575,11775645],"length":1,"stats":{"Line":0}},{"line":1543,"address":[11775613,11775552],"length":1,"stats":{"Line":0}},{"line":1544,"address":[11775708],"length":1,"stats":{"Line":0}},{"line":1545,"address":[11775794],"length":1,"stats":{"Line":0}},{"line":1547,"address":[11778225,11778276,11775746],"length":1,"stats":{"Line":0}},{"line":1548,"address":[11778640,11778231],"length":1,"stats":{"Line":0}},{"line":1551,"address":[11778140,11775864,11775951],"length":1,"stats":{"Line":0}},{"line":1552,"address":[11776092,11776163],"length":1,"stats":{"Line":0}},{"line":1553,"address":[11776339,11776237],"length":1,"stats":{"Line":0}},{"line":1554,"address":[11776294,11778084],"length":1,"stats":{"Line":0}},{"line":1556,"address":[11776468,11776552],"length":1,"stats":{"Line":0}},{"line":1557,"address":[11776703,11777979,11776794],"length":1,"stats":{"Line":0}},{"line":1558,"address":[11777029],"length":1,"stats":{"Line":0}},{"line":1559,"address":[11777188,11777041],"length":1,"stats":{"Line":0}},{"line":1561,"address":[11777459,11777064,11777627],"length":1,"stats":{"Line":0}},{"line":1562,"address":[11777469],"length":1,"stats":{"Line":0}},{"line":1564,"address":[11771976,11772098,11775345,11772177,11772247],"length":1,"stats":{"Line":0}},{"line":1566,"address":[11772154,11772215],"length":1,"stats":{"Line":0}},{"line":1567,"address":[11772310],"length":1,"stats":{"Line":0}},{"line":1568,"address":[11772396],"length":1,"stats":{"Line":0}},{"line":1570,"address":[11772348,11774878,11774827],"length":1,"stats":{"Line":0}},{"line":1571,"address":[11774833,11775242],"length":1,"stats":{"Line":0}},{"line":1574,"address":[11772553,11772466,11774742],"length":1,"stats":{"Line":0}},{"line":1575,"address":[11772765,11772694],"length":1,"stats":{"Line":0}},{"line":1576,"address":[11772839,11772941],"length":1,"stats":{"Line":0}},{"line":1577,"address":[11772896,11774686],"length":1,"stats":{"Line":0}},{"line":1579,"address":[11773154,11773070],"length":1,"stats":{"Line":0}},{"line":1580,"address":[11773305,11773396,11774581],"length":1,"stats":{"Line":0}},{"line":1581,"address":[11773631],"length":1,"stats":{"Line":0}},{"line":1582,"address":[11773790,11773643],"length":1,"stats":{"Line":0}},{"line":1584,"address":[11774061,11774229,11773666],"length":1,"stats":{"Line":0}},{"line":1585,"address":[11774071],"length":1,"stats":{"Line":0}},{"line":1588,"address":[11771704,11778786],"length":1,"stats":{"Line":0}},{"line":1591,"address":[11779039,11779013,11771633],"length":1,"stats":{"Line":0}},{"line":1600,"address":[11779026],"length":1,"stats":{"Line":0}},{"line":1601,"address":[11779607,11779522],"length":1,"stats":{"Line":0}},{"line":1602,"address":[11779844,11779872,11779754],"length":1,"stats":{"Line":0}},{"line":1605,"address":[11779542],"length":1,"stats":{"Line":0}},{"line":1608,"address":[11783127,11781056,11783087],"length":1,"stats":{"Line":0}},{"line":1613,"address":[11781167],"length":1,"stats":{"Line":0}},{"line":1614,"address":[11781204,11781291],"length":1,"stats":{"Line":0}},{"line":1615,"address":[11781363,11781510],"length":1,"stats":{"Line":0}},{"line":1617,"address":[11783218,11783147,11781389],"length":1,"stats":{"Line":0}},{"line":1621,"address":[11783161],"length":1,"stats":{"Line":0}},{"line":1624,"address":[11781596,11781693],"length":1,"stats":{"Line":0}},{"line":1625,"address":[11781788,11781906],"length":1,"stats":{"Line":0}},{"line":1627,"address":[11782141,11782051,11782171],"length":1,"stats":{"Line":0}},{"line":1628,"address":[11782155],"length":1,"stats":{"Line":0}},{"line":1630,"address":[11781990],"length":1,"stats":{"Line":0}},{"line":1631,"address":[11782507,11782006,11782551],"length":1,"stats":{"Line":0}},{"line":1632,"address":[11782521],"length":1,"stats":{"Line":0}},{"line":1637,"address":[11783584,11784926,11784932],"length":1,"stats":{"Line":0}},{"line":1644,"address":[11783761],"length":1,"stats":{"Line":0}},{"line":1645,"address":[11783804,11783881],"length":1,"stats":{"Line":0}},{"line":1646,"address":[11783915],"length":1,"stats":{"Line":0}},{"line":1648,"address":[11784135,11784018,11784108],"length":1,"stats":{"Line":0}},{"line":1649,"address":[11784119],"length":1,"stats":{"Line":0}},{"line":1651,"address":[11783957],"length":1,"stats":{"Line":0}},{"line":1652,"address":[11783973,11784471,11784512],"length":1,"stats":{"Line":0}},{"line":1653,"address":[11784482],"length":1,"stats":{"Line":0}},{"line":1659,"address":[11785682,11784960,11785688],"length":1,"stats":{"Line":0}},{"line":1660,"address":[11785032],"length":1,"stats":{"Line":0}},{"line":1661,"address":[11785156,11785428,11785639],"length":1,"stats":{"Line":0}},{"line":1662,"address":[11785601],"length":1,"stats":{"Line":0}},{"line":1676,"address":[11785208,11785701],"length":1,"stats":{"Line":0}},{"line":1677,"address":[11785942],"length":1,"stats":{"Line":0}},{"line":1689,"address":[11785959,11785822],"length":1,"stats":{"Line":0}},{"line":1690,"address":[11786086],"length":1,"stats":{"Line":0}},{"line":1694,"address":[11786173,11786047],"length":1,"stats":{"Line":0}},{"line":1695,"address":[11786103,11786718,11786570,11786512],"length":1,"stats":{"Line":0}},{"line":1698,"address":[11786443],"length":1,"stats":{"Line":0}},{"line":1699,"address":[11786476],"length":1,"stats":{"Line":0}},{"line":1701,"address":[11786629,11786703,11786686],"length":1,"stats":{"Line":0}},{"line":1702,"address":[11786691],"length":1,"stats":{"Line":0}},{"line":1704,"address":[11786646],"length":1,"stats":{"Line":0}},{"line":1710,"address":[11786768,11793311,11793317],"length":1,"stats":{"Line":7}},{"line":1712,"address":[11786807],"length":1,"stats":{"Line":7}},{"line":1713,"address":[11787031],"length":1,"stats":{"Line":7}},{"line":1714,"address":[11787187],"length":1,"stats":{"Line":1}},{"line":1716,"address":[11787164],"length":1,"stats":{"Line":3}},{"line":1717,"address":[11787258],"length":1,"stats":{"Line":1}},{"line":1719,"address":[11787235],"length":1,"stats":{"Line":3}},{"line":1720,"address":[11787329],"length":1,"stats":{"Line":1}},{"line":1722,"address":[11787303],"length":1,"stats":{"Line":3}},{"line":1723,"address":[11787358],"length":1,"stats":{"Line":1}},{"line":1727,"address":[11787409,11787074],"length":1,"stats":{"Line":4}},{"line":1728,"address":[11787692,11787615],"length":1,"stats":{"Line":9}},{"line":1730,"address":[11787708,11787774],"length":1,"stats":{"Line":7}},{"line":1731,"address":[11787810,11787751],"length":1,"stats":{"Line":8}},{"line":1732,"address":[11787944,11788010],"length":1,"stats":{"Line":7}},{"line":1733,"address":[11788046,11787987],"length":1,"stats":{"Line":11}},{"line":1734,"address":[11788180,11788246],"length":1,"stats":{"Line":7}},{"line":1735,"address":[11788321,11788282,11788223],"length":1,"stats":{"Line":12}},{"line":1736,"address":[11788396,11788357,11788298],"length":1,"stats":{"Line":12}},{"line":1737,"address":[11788432,11788471,11788373],"length":1,"stats":{"Line":12}},{"line":1738,"address":[11788448,11788507,11788546],"length":1,"stats":{"Line":12}},{"line":1739,"address":[11788523,11788582,11788621],"length":1,"stats":{"Line":12}},{"line":1740,"address":[11788598,11788696,11788657],"length":1,"stats":{"Line":12}},{"line":1741,"address":[11788771,11788673,11788732],"length":1,"stats":{"Line":12}},{"line":1742,"address":[11788748,11788807],"length":1,"stats":{"Line":9}},{"line":1743,"address":[11788964,11788898],"length":1,"stats":{"Line":2}},{"line":1744,"address":[11789000,11788941],"length":1,"stats":{"Line":5}},{"line":1745,"address":[11789091],"length":1,"stats":{"Line":3}},{"line":1746,"address":[11789209],"length":1,"stats":{"Line":1}},{"line":1747,"address":[11789436,11789370],"length":1,"stats":{"Line":2}},{"line":1748,"address":[11789413,11789472,11789511],"length":1,"stats":{"Line":9}},{"line":1750,"address":[11789488,11789586,11789547],"length":1,"stats":{"Line":10}},{"line":1751,"address":[11789563,11789661,11789622],"length":1,"stats":{"Line":10}},{"line":1752,"address":[11789638,11789736,11789697],"length":1,"stats":{"Line":9}},{"line":1753,"address":[11789713,11789772,11789811],"length":1,"stats":{"Line":8}},{"line":1755,"address":[11789847,11789886,11789788],"length":1,"stats":{"Line":10}},{"line":1756,"address":[11789922,11789863],"length":1,"stats":{"Line":9}},{"line":1757,"address":[11790079,11790013],"length":1,"stats":{"Line":4}},{"line":1759,"address":[11790115,11790056],"length":1,"stats":{"Line":9}},{"line":1760,"address":[11790206],"length":1,"stats":{"Line":6}},{"line":1761,"address":[11790476,11790410],"length":1,"stats":{"Line":4}},{"line":1762,"address":[11790453,11790512,11790551],"length":1,"stats":{"Line":9}},{"line":1763,"address":[11790528,11790587],"length":1,"stats":{"Line":8}},{"line":1764,"address":[11790744,11790678],"length":1,"stats":{"Line":5}},{"line":1765,"address":[11790721,11790780,11790819],"length":1,"stats":{"Line":6}},{"line":1766,"address":[11790796,11790855],"length":1,"stats":{"Line":5}},{"line":1767,"address":[11791032,11791098],"length":1,"stats":{"Line":4}},{"line":1769,"address":[11791134,11791075],"length":1,"stats":{"Line":5}},{"line":1770,"address":[11791334,11791268],"length":1,"stats":{"Line":2}},{"line":1771,"address":[11791409,11791370,11791311],"length":1,"stats":{"Line":6}},{"line":1772,"address":[11791484,11791386,11791445],"length":1,"stats":{"Line":4}},{"line":1773,"address":[11791461,11791559,11791520],"length":1,"stats":{"Line":3}},{"line":1775,"address":[11791634,11791536,11791595],"length":1,"stats":{"Line":9}},{"line":1777,"address":[11791670,11791709,11791611],"length":1,"stats":{"Line":5}},{"line":1779,"address":[11791686,11791745],"length":1,"stats":{"Line":4}},{"line":1780,"address":[11791902,11791836],"length":1,"stats":{"Line":3}},{"line":1781,"address":[11791938,11791879,11791977],"length":1,"stats":{"Line":6}},{"line":1782,"address":[11792052,11791954,11792013],"length":1,"stats":{"Line":6}},{"line":1783,"address":[11792127,11792029,11792088],"length":1,"stats":{"Line":6}},{"line":1784,"address":[11792163,11792202,11792104],"length":1,"stats":{"Line":6}},{"line":1785,"address":[11792179,11792238,11792277],"length":1,"stats":{"Line":6}},{"line":1786,"address":[11792254,11792313,11792352],"length":1,"stats":{"Line":6}},{"line":1787,"address":[11792427,11792329,11792388],"length":1,"stats":{"Line":5}},{"line":1788,"address":[11792463,11792502,11792404],"length":1,"stats":{"Line":6}},{"line":1790,"address":[11792577,11792997],"length":1,"stats":{"Line":3}},{"line":1793,"address":[11793091],"length":1,"stats":{"Line":1}},{"line":1794,"address":[11793280],"length":1,"stats":{"Line":0}},{"line":1800,"address":[11801329,11793344,11795079],"length":1,"stats":{"Line":1}},{"line":1801,"address":[11793379],"length":1,"stats":{"Line":1}},{"line":1802,"address":[11793546],"length":1,"stats":{"Line":1}},{"line":1803,"address":[11793477],"length":1,"stats":{"Line":0}},{"line":1804,"address":[11793517,11801387],"length":1,"stats":{"Line":0}},{"line":1805,"address":[11801961,11801472,11801916],"length":1,"stats":{"Line":0}},{"line":1806,"address":[11801922,11802237],"length":1,"stats":{"Line":0}},{"line":1808,"address":[11801602,11801430,11801521],"length":1,"stats":{"Line":0}},{"line":1809,"address":[11801877,11801527],"length":1,"stats":{"Line":0}},{"line":1814,"address":[11793570,11793641],"length":1,"stats":{"Line":2}},{"line":1815,"address":[11793718,11793893],"length":1,"stats":{"Line":0}},{"line":1816,"address":[11793856],"length":1,"stats":{"Line":0}},{"line":1817,"address":[11794035,11793899],"length":1,"stats":{"Line":0}},{"line":1818,"address":[11793998],"length":1,"stats":{"Line":0}},{"line":1820,"address":[11794521,11794572,11793934],"length":1,"stats":{"Line":0}},{"line":1821,"address":[11794527,11794872],"length":1,"stats":{"Line":0}},{"line":1823,"address":[11794041,11794180],"length":1,"stats":{"Line":0}},{"line":1824,"address":[11794099,11794479],"length":1,"stats":{"Line":0}},{"line":1828,"address":[11795107,11801311,11795169],"length":1,"stats":{"Line":2}},{"line":1829,"address":[11801223,11795318,11795386],"length":1,"stats":{"Line":2}},{"line":1830,"address":[11795523,11801189],"length":1,"stats":{"Line":1}},{"line":1831,"address":[11801143,11795692],"length":1,"stats":{"Line":1}},{"line":1833,"address":[11795928,11796048],"length":1,"stats":{"Line":2}},{"line":1834,"address":[11796146,11796086],"length":1,"stats":{"Line":2}},{"line":1835,"address":[11796162],"length":1,"stats":{"Line":1}},{"line":1836,"address":[11796460,11796613,11801081],"length":1,"stats":{"Line":2}},{"line":1837,"address":[11796849,11796754],"length":1,"stats":{"Line":2}},{"line":1838,"address":[11796920],"length":1,"stats":{"Line":1}},{"line":1839,"address":[11796990],"length":1,"stats":{"Line":1}},{"line":1840,"address":[11797029],"length":1,"stats":{"Line":1}},{"line":1842,"address":[11797086,11800780,11800729],"length":1,"stats":{"Line":0}},{"line":1843,"address":[11800735,11801029],"length":1,"stats":{"Line":0}},{"line":1846,"address":[11797134],"length":1,"stats":{"Line":1}},{"line":1847,"address":[11800682,11797347,11797434],"length":1,"stats":{"Line":2}},{"line":1848,"address":[11797654,11797575],"length":1,"stats":{"Line":2}},{"line":1849,"address":[11800572,11797983,11797703],"length":1,"stats":{"Line":2}},{"line":1850,"address":[11800518,11798415],"length":1,"stats":{"Line":1}},{"line":1852,"address":[11797753,11797929,11797660],"length":1,"stats":{"Line":2}},{"line":1854,"address":[11797891],"length":1,"stats":{"Line":1}},{"line":1855,"address":[11800401,11798907,11798702,11798811],"length":1,"stats":{"Line":2}},{"line":1856,"address":[11798694],"length":1,"stats":{"Line":2}},{"line":1857,"address":[12103202],"length":1,"stats":{"Line":1}},{"line":1859,"address":[12103572,12103411],"length":1,"stats":{"Line":2}},{"line":1860,"address":[12103706,12103598],"length":1,"stats":{"Line":1}},{"line":1864,"address":[12103481,12104000],"length":1,"stats":{"Line":0}},{"line":1865,"address":[12104032],"length":1,"stats":{"Line":0}},{"line":1869,"address":[12103251,12104403],"length":1,"stats":{"Line":0}},{"line":1870,"address":[12104435],"length":1,"stats":{"Line":0}},{"line":1881,"address":[11799077,11798956],"length":1,"stats":{"Line":1}},{"line":1882,"address":[11799050,11799095],"length":1,"stats":{"Line":2}},{"line":1883,"address":[11799421],"length":1,"stats":{"Line":0}},{"line":1897,"address":[11796516],"length":1,"stats":{"Line":1}},{"line":1901,"address":[11803658,11802320,11803506],"length":1,"stats":{"Line":2}},{"line":1902,"address":[11802371],"length":1,"stats":{"Line":1}},{"line":1903,"address":[11802530,11802437,11802564],"length":1,"stats":{"Line":9}},{"line":1904,"address":[11802554,11802924,11803611],"length":1,"stats":{"Line":6}},{"line":1905,"address":[11803138],"length":1,"stats":{"Line":3}},{"line":1906,"address":[11803142,11803327],"length":1,"stats":{"Line":6}},{"line":1908,"address":[11803250],"length":1,"stats":{"Line":3}},{"line":1912,"address":[11803696],"length":1,"stats":{"Line":1}},{"line":1913,"address":[11803729,11804100],"length":1,"stats":{"Line":2}},{"line":1915,"address":[11803764],"length":1,"stats":{"Line":1}},{"line":1930,"address":[11804007],"length":1,"stats":{"Line":1}},{"line":1934,"address":[11805739,11804240,11806587],"length":1,"stats":{"Line":0}},{"line":1939,"address":[11804349],"length":1,"stats":{"Line":0}},{"line":1940,"address":[11804542,11804459],"length":1,"stats":{"Line":0}},{"line":1941,"address":[11806569,11804628,11804759],"length":1,"stats":{"Line":0}},{"line":1942,"address":[11804945],"length":1,"stats":{"Line":0}},{"line":1943,"address":[11805041,11804964],"length":1,"stats":{"Line":0}},{"line":1945,"address":[11805202,11805761,11805137],"length":1,"stats":{"Line":0}},{"line":1946,"address":[11805394,11805493,11805682],"length":1,"stats":{"Line":0}},{"line":1949,"address":[11805164,11805787,11806494],"length":1,"stats":{"Line":0}},{"line":1950,"address":[11806466,11805981,11806032],"length":1,"stats":{"Line":0}},{"line":1951,"address":[11806221,11806399,11806138],"length":1,"stats":{"Line":0}},{"line":1956,"address":[11804663],"length":1,"stats":{"Line":0}},{"line":1960,"address":[11807767,11807796,11806608],"length":1,"stats":{"Line":1}},{"line":1961,"address":[11806651],"length":1,"stats":{"Line":1}},{"line":1964,"address":[11806759],"length":1,"stats":{"Line":3}},{"line":1965,"address":[12104644],"length":1,"stats":{"Line":1}},{"line":1966,"address":[12104638],"length":1,"stats":{"Line":1}},{"line":1969,"address":[11807125],"length":1,"stats":{"Line":1}},{"line":1971,"address":[11806920,11806801,11806874,11806996,11807773,11807093],"length":1,"stats":{"Line":4}},{"line":1972,"address":[11806889,11806966],"length":1,"stats":{"Line":1}},{"line":1973,"address":[11807066],"length":1,"stats":{"Line":1}},{"line":1975,"address":[11807240,11807327],"length":1,"stats":{"Line":2}},{"line":1976,"address":[11807495],"length":1,"stats":{"Line":1}},{"line":1977,"address":[11807610],"length":1,"stats":{"Line":1}},{"line":1985,"address":[11809215,11807840,11809209],"length":1,"stats":{"Line":1}},{"line":1990,"address":[11807907,11808054,11808277,11808360,11809228],"length":1,"stats":{"Line":2}},{"line":1992,"address":[11808328,11808256],"length":1,"stats":{"Line":2}},{"line":1994,"address":[11808605,11808538],"length":1,"stats":{"Line":2}},{"line":1995,"address":[11808668,11808750],"length":1,"stats":{"Line":1}},{"line":1997,"address":[11808852,11808752],"length":1,"stats":{"Line":2}},{"line":2000,"address":[11808783,11808925],"length":1,"stats":{"Line":2}},{"line":2003,"address":[11809118],"length":1,"stats":{"Line":1}},{"line":2004,"address":[11808994,11808814],"length":1,"stats":{"Line":2}},{"line":2005,"address":[11809078,11809002],"length":1,"stats":{"Line":2}},{"line":2010,"address":[11808707],"length":1,"stats":{"Line":1}},{"line":2013,"address":[11809280],"length":1,"stats":{"Line":0}},{"line":2018,"address":[12104885,12105152,12105099,12105996],"length":1,"stats":{"Line":0}},{"line":2019,"address":[12108272,12108288,12105053],"length":1,"stats":{"Line":0}},{"line":2020,"address":[12105076,12108384,12108474],"length":1,"stats":{"Line":0}},{"line":2023,"address":[12108400],"length":1,"stats":{"Line":0}},{"line":2025,"address":[12105264,12105440,12105974,12105604],"length":1,"stats":{"Line":0}},{"line":2026,"address":[12105339],"length":1,"stats":{"Line":0}},{"line":2030,"address":[12031234],"length":1,"stats":{"Line":0}},{"line":2031,"address":[12106717,12106790],"length":1,"stats":{"Line":0}},{"line":2033,"address":[12108505,12108496,12106670],"length":1,"stats":{"Line":0}},{"line":2035,"address":[12106939,12106872,12106797],"length":1,"stats":{"Line":0}},{"line":2037,"address":[12108528,12108537,12106837],"length":1,"stats":{"Line":0}},{"line":2039,"address":[12106946],"length":1,"stats":{"Line":0}},{"line":2045,"address":[12107119],"length":1,"stats":{"Line":0}},{"line":2046,"address":[12031252],"length":1,"stats":{"Line":0}},{"line":2047,"address":[12107829,12107900],"length":1,"stats":{"Line":0}},{"line":2048,"address":[12108011],"length":1,"stats":{"Line":0}},{"line":2053,"address":[11809951,11810015,11809376],"length":1,"stats":{"Line":0}},{"line":2057,"address":[11809596,11809393,11809503],"length":1,"stats":{"Line":0}},{"line":2058,"address":[11809712,11809656],"length":1,"stats":{"Line":0}},{"line":2059,"address":[11809839,11809740],"length":1,"stats":{"Line":0}},{"line":2106,"address":[11810000],"length":1,"stats":{"Line":0}},{"line":2111,"address":[11811429,11810032],"length":1,"stats":{"Line":0}},{"line":2118,"address":[11810227,11810160],"length":1,"stats":{"Line":0}},{"line":2122,"address":[11810493,11810568],"length":1,"stats":{"Line":0}},{"line":2123,"address":[11810657],"length":1,"stats":{"Line":0}},{"line":2124,"address":[11810741],"length":1,"stats":{"Line":0}},{"line":2126,"address":[11810702],"length":1,"stats":{"Line":0}},{"line":2127,"address":[11810771,11810885],"length":1,"stats":{"Line":0}},{"line":2128,"address":[11810915,11810809],"length":1,"stats":{"Line":0}},{"line":2129,"address":[11810847,11810917],"length":1,"stats":{"Line":0}},{"line":2131,"address":[11810935,11811375,11810908],"length":1,"stats":{"Line":0}},{"line":2132,"address":[11811148],"length":1,"stats":{"Line":0}},{"line":2133,"address":[11811239,11811169],"length":1,"stats":{"Line":0}},{"line":2135,"address":[11811204,11811277],"length":1,"stats":{"Line":0}},{"line":2136,"address":[11811296],"length":1,"stats":{"Line":0}},{"line":2140,"address":[11812877,11812883,11811456],"length":1,"stats":{"Line":0}},{"line":2141,"address":[11811508],"length":1,"stats":{"Line":0}},{"line":2143,"address":[11811703,11811792],"length":1,"stats":{"Line":0}},{"line":2144,"address":[11812226,11812851],"length":1,"stats":{"Line":0}},{"line":2145,"address":[11812443],"length":1,"stats":{"Line":0}},{"line":2147,"address":[11811963,11811883],"length":1,"stats":{"Line":0}},{"line":2149,"address":[11811935],"length":1,"stats":{"Line":0}},{"line":2153,"address":[11813708,11812896,11813714],"length":1,"stats":{"Line":0}},{"line":2158,"address":[11812999,11813374,11813309],"length":1,"stats":{"Line":0}},{"line":2160,"address":[11813125],"length":1,"stats":{"Line":0}},{"line":2163,"address":[11813222],"length":1,"stats":{"Line":0}},{"line":2164,"address":[11813253],"length":1,"stats":{"Line":0}},{"line":2166,"address":[11813627,11813693,11813582],"length":1,"stats":{"Line":0}},{"line":2167,"address":[11813629,11813677],"length":1,"stats":{"Line":0}},{"line":2169,"address":[11813616],"length":1,"stats":{"Line":0}},{"line":2175,"address":[11818781,11813744,11817790],"length":1,"stats":{"Line":1}},{"line":2176,"address":[11813783],"length":1,"stats":{"Line":1}},{"line":2177,"address":[11818763,11814083,11814016],"length":1,"stats":{"Line":2}},{"line":2178,"address":[11814302],"length":1,"stats":{"Line":1}},{"line":2179,"address":[11814318],"length":1,"stats":{"Line":1}},{"line":2181,"address":[11814444],"length":1,"stats":{"Line":1}},{"line":2182,"address":[12108752,12108764],"length":1,"stats":{"Line":3}},{"line":2183,"address":[11814777],"length":1,"stats":{"Line":1}},{"line":2190,"address":[11818672,11815058],"length":1,"stats":{"Line":1}},{"line":2191,"address":[11815319,11815242],"length":1,"stats":{"Line":2}},{"line":2192,"address":[11815325,11815418],"length":1,"stats":{"Line":2}},{"line":2194,"address":[11815504,11818616,11815577],"length":1,"stats":{"Line":0}},{"line":2199,"address":[11815658,11818579],"length":1,"stats":{"Line":0}},{"line":2201,"address":[11815872],"length":1,"stats":{"Line":0}},{"line":2202,"address":[11815911,11816079],"length":1,"stats":{"Line":0}},{"line":2206,"address":[11816313,11816539,11818525,11816438,11816597,11816395,11816191],"length":1,"stats":{"Line":0}},{"line":2208,"address":[11816329],"length":1,"stats":{"Line":0}},{"line":2210,"address":[11816411],"length":1,"stats":{"Line":0}},{"line":2211,"address":[11816454],"length":1,"stats":{"Line":0}},{"line":2214,"address":[11816678],"length":1,"stats":{"Line":0}},{"line":2215,"address":[11816709],"length":1,"stats":{"Line":0}},{"line":2216,"address":[11816754],"length":1,"stats":{"Line":0}},{"line":2217,"address":[11816799],"length":1,"stats":{"Line":0}},{"line":2218,"address":[11816844],"length":1,"stats":{"Line":0}},{"line":2219,"address":[11816889],"length":1,"stats":{"Line":0}},{"line":2220,"address":[11816934],"length":1,"stats":{"Line":0}},{"line":2221,"address":[11816979],"length":1,"stats":{"Line":0}},{"line":2222,"address":[11817024],"length":1,"stats":{"Line":0}},{"line":2225,"address":[11815876,11815954],"length":1,"stats":{"Line":0}},{"line":2228,"address":[11816033,11817103],"length":1,"stats":{"Line":0}},{"line":2232,"address":[11817222],"length":1,"stats":{"Line":0}},{"line":2233,"address":[11817881,11817259,11818102,11818044,11818471,11817951,11817988],"length":1,"stats":{"Line":0}},{"line":2235,"address":[11817897],"length":1,"stats":{"Line":0}},{"line":2237,"address":[11817967],"length":1,"stats":{"Line":0}},{"line":2238,"address":[11818004],"length":1,"stats":{"Line":0}},{"line":2242,"address":[11817228,11817505,11817656,11817752,11817384,11817542,11817598],"length":1,"stats":{"Line":0}},{"line":2244,"address":[11817400],"length":1,"stats":{"Line":0}},{"line":2247,"address":[11817521],"length":1,"stats":{"Line":0}},{"line":2248,"address":[11817558],"length":1,"stats":{"Line":0}},{"line":2252,"address":[11817728,11818176,11818320],"length":1,"stats":{"Line":0}},{"line":2253,"address":[11818289,11818218],"length":1,"stats":{"Line":0}},{"line":2254,"address":[11818308],"length":1,"stats":{"Line":0}},{"line":2256,"address":[11818182,11818254],"length":1,"stats":{"Line":0}},{"line":2261,"address":[11823358,11823048,11818800],"length":1,"stats":{"Line":0}},{"line":2262,"address":[11818864],"length":1,"stats":{"Line":0}},{"line":2263,"address":[11823340,11819081,11819148],"length":1,"stats":{"Line":0}},{"line":2264,"address":[11819367],"length":1,"stats":{"Line":0}},{"line":2265,"address":[11819383],"length":1,"stats":{"Line":0}},{"line":2267,"address":[12108800,12108819,12108944,12108966],"length":1,"stats":{"Line":0}},{"line":2268,"address":[11819516],"length":1,"stats":{"Line":0}},{"line":2269,"address":[11819546,11819641],"length":1,"stats":{"Line":0}},{"line":2277,"address":[11823229,11820178,11820382,11820444,11820502],"length":1,"stats":{"Line":0}},{"line":2279,"address":[11820316],"length":1,"stats":{"Line":0}},{"line":2281,"address":[11820398],"length":1,"stats":{"Line":0}},{"line":2283,"address":[11820583],"length":1,"stats":{"Line":0}},{"line":2284,"address":[11820695,11820610],"length":1,"stats":{"Line":0}},{"line":2287,"address":[11820652,11823192,11820749],"length":1,"stats":{"Line":0}},{"line":2288,"address":[11820985,11823155,11820890],"length":1,"stats":{"Line":0}},{"line":2291,"address":[11821187,11823118],"length":1,"stats":{"Line":0}},{"line":2292,"address":[11821467,11821390],"length":1,"stats":{"Line":0}},{"line":2293,"address":[11821579],"length":1,"stats":{"Line":0}},{"line":2296,"address":[11822067,11821433,11823064,11822127],"length":1,"stats":{"Line":0}},{"line":2298,"address":[11821720],"length":1,"stats":{"Line":0}},{"line":2301,"address":[11821816],"length":1,"stats":{"Line":0}},{"line":2303,"address":[11822345],"length":1,"stats":{"Line":0}},{"line":2304,"address":[11822374,11822449],"length":1,"stats":{"Line":0}},{"line":2307,"address":[11822410,11822497],"length":1,"stats":{"Line":0}},{"line":2308,"address":[11822516,11822599],"length":1,"stats":{"Line":0}},{"line":2309,"address":[11822850,11822673],"length":1,"stats":{"Line":0}},{"line":2311,"address":[11822647,11822702],"length":1,"stats":{"Line":0}},{"line":2312,"address":[11822721],"length":1,"stats":{"Line":0}},{"line":2314,"address":[11822819],"length":1,"stats":{"Line":0}},{"line":2318,"address":[11823376,11826344,11826525],"length":1,"stats":{"Line":0}},{"line":2319,"address":[11823440],"length":1,"stats":{"Line":0}},{"line":2320,"address":[11823657,11826507,11823724],"length":1,"stats":{"Line":0}},{"line":2321,"address":[11823943],"length":1,"stats":{"Line":0}},{"line":2322,"address":[11823959],"length":1,"stats":{"Line":0}},{"line":2324,"address":[12109206,12109040,12109184,12109059],"length":1,"stats":{"Line":0}},{"line":2325,"address":[12109232,12109244],"length":1,"stats":{"Line":0}},{"line":2326,"address":[11824217,11824122],"length":1,"stats":{"Line":0}},{"line":2334,"address":[11824754,11826416],"length":1,"stats":{"Line":0}},{"line":2335,"address":[11824938,11825027],"length":1,"stats":{"Line":0}},{"line":2337,"address":[11826360,11825102],"length":1,"stats":{"Line":0}},{"line":2338,"address":[11825287],"length":1,"stats":{"Line":0}},{"line":2339,"address":[11825291,11825369],"length":1,"stats":{"Line":0}},{"line":2340,"address":[11825438],"length":1,"stats":{"Line":0}},{"line":2343,"address":[11825472,11825326],"length":1,"stats":{"Line":0}},{"line":2347,"address":[11825770,11825807,11826306,11825863,11825584,11825921],"length":1,"stats":{"Line":0}},{"line":2349,"address":[11825716],"length":1,"stats":{"Line":0}},{"line":2351,"address":[11825786],"length":1,"stats":{"Line":0}},{"line":2352,"address":[11825823],"length":1,"stats":{"Line":0}},{"line":2354,"address":[11825996,11826155],"length":1,"stats":{"Line":0}},{"line":2355,"address":[11826124,11826053],"length":1,"stats":{"Line":0}},{"line":2356,"address":[11826143],"length":1,"stats":{"Line":0}},{"line":2358,"address":[11826089,11826017],"length":1,"stats":{"Line":0}}],"covered":374,"coverable":860},{"path":["/","home","md","language","mdcode","tmp-smoke","hello.rs"],"content":"fn main() { println!(\\hi\\); }\n// change\n","traces":[],"covered":0,"coverable":0}],"coverage":43.48837209302325,"covered":374,"coverable":860}