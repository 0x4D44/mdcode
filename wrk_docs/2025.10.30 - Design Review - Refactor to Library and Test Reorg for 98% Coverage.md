# Design Review: Refactor to Library and Test Reorg for 98% Coverage

Date: 2025-10-30
Owner: md
Repo: mdcode (Rust crate/CLI)

## 1) Executive Summary
The original design (Refactor to Library and Test Reorg for 98% Coverage) is sound in intent: split the crate into a library for production logic and a thin binary, then move tests to integration suites to prevent test lines from inflating LLVM’s denominator. A trial implementation revealed several practical pitfalls that could slow adoption or cause regressions. This review documents the issues, proposes concrete remedies, and updates the design to reduce risk and ensure the team can confidently reach ≥98% LLVM coverage and ≥95% Tarpaulin with stable behavior.

## 2) What We Tried and What Broke
A quick lib/bin split plus auto‑migrating tests exposed the following:
- API drift and test expectations
  - Some helper functions changed behavior or signatures (e.g., `detect_file_type`, `build_repo_create_payload` shape). Tests expected prior behavior.
  - Simplification of implementations (e.g., `checkout_tree_to_dir` non‑recursive, `is_dirty` blob lookup path) caused semantic differences.
- Surprise dependency introduction
  - Using the `which` crate to locate `gh` added a new dependency. The original design stated no dep changes.
- `cfg(tarpaulin)` warnings
  - Rust warned about unknown cfg unless check‑cfg is declared, cluttering builds.
- Coverage semantics
  - Even after a split, cargo‑llvm‑cov can still include bin/tests unless we opt for `--lib` or suitable excludes. Relying only on moving tests may not guarantee ≥98%.
- Async boundary (Tokio runtime)
  - Spawning a `tokio::runtime::Runtime` inside core paths complicates library execution in tests. Better to push async to the boundary (CLI) or inject a GH backend.
- Platform‑specific paths
  - `launch_diff_tool` success path depended on `true` (Unix only) and required `#[cfg(unix)]` guards, already present in current tests.

## 3) Updated Principles
- Behavioral parity first: preserve function signatures and semantics; do not modify classification, logging, or error strings during refactor.
- No new hard dependencies unless justified; prefer std or optional features.
- Treat the CLI as an adapter; the library owns domain behavior and provides deterministic APIs for tests.
- Make coverage measurement intentional: explicitly scope reports to the library target.

## 4) Issues, Root Causes, and Fixes

1. API drift (changed behavior of helpers)
- Issue: Modifying `detect_file_type`/payload builders or replacing logic leads to broken tests and behavior changes.
- Fix: Lift existing implementations verbatim into lib. If changes are required, stage them after coverage goals and document in a separate PR.

2. New dependency (`which`) for `gh_cli_path`
- Issue: Pulls in an extra crate and can be avoided.
- Fix: Implement a small internal helper: iterate `PATH` and look for an executable named `gh` (Windows: `gh.exe`). Offer `which` under an optional feature flag only if really desirable later.

3. `cfg(tarpaulin)` warnings
- Issue: Rust warns about unknown cfg unless declared.
- Fix: Add check‑cfg lint so the cfg is recognized. In `Cargo.toml`:
  ```toml
  [lints.rust]
  unexpected_cfgs = { level = "warn", check-cfg = ["cfg(tarpaulin)"] }
  ```
  Alternatively, remove `cfg(tarpaulin)` and rely on runtime guards, but existing pattern is fine with check‑cfg.

4. Coverage still includes non‑library code
- Issue: Even with tests moved, references to bin/test targets can still participate in coverage.
- Fix: Run cargo‑llvm‑cov with library scope for metrics and gates.
  - Makefile: `cargo llvm-cov --lib --summary-only --json --output-path target/coverage/llvm-summary.json`
  - For local triage: `cargo llvm-cov --lib --json --output-path target/coverage/llvm-detailed.json`
  - Keep Tarpaulin as‑is; it already focuses on Rust code but validate behavior.

5. Async GH creation and runtime boundaries
- Issue: Creating a runtime in library code complicates testing and layering.
- Fix: Define a GH backend interface and inject it:
  - Trait: `trait GhBackend { fn create_repo(&self, name:&str, desc:Option<&str>, vis:RepoVisibility) -> Result<String, Box<dyn Error>>; }`
  - Implementations:
    - `GhCliBackend` (shells out to `gh`)
    - `StubBackend` (returns a temp bare repo path, no network)
    - `GhApiBackend` (future, async; only used by CLI with runtime)
  - The CLI chooses the backend: prefer CLI if present; otherwise Stub; later, optionally API.
  - This keeps lib synchronous and tests deterministic.

6. Git tree checkout correctness
- Issue: A non‑recursive `checkout_tree_to_dir` breaks nested trees.
- Fix: Keep or implement recursive traversal matching current semantics (walk subtrees and create directories as needed).

7. `is_dirty` correctness and performance
- Issue: Comparing blobs incorrectly or skipping HEAD path checks leads to wrong results.
- Fix: Preserve the current algorithm (statuses → early exits for staged changes → compare HEAD blob vs worktree with CRLF→LF normalization). Do not rewrite unless covered by tests.

8. Test flakiness on pull behavior (`git pull` rebase decision)
- Issue: Git may ask to reconcile divergent branches.
- Fix: Prefer explicit flags for pull in tests or use `fetch` + `merge --no-edit` where feasible. Current tests already exercise conflict paths; keep them stable.

9. Logging in tests
- Issue: Reinitializing global logger causes warnings.
- Fix: Keep `ensure_test_logger()` behind `#[cfg(test)]` in lib, and keep main’s `env_logger` init in the binary only.

10. Windows compatibility and line endings
- Issue: `is_dirty` EOL handling must remain stable across platforms.
- Fix: Keep normalization and `core.autocrlf=false` config in tests; do not alter logic during refactor.

## 5) Updated Architecture
- `src/lib.rs` provides all current functions unchanged; modules may be introduced for structure without changing public signatures.
- `src/main.rs` becomes a thin wrapper that:
  - Initializes logging.
  - Parses CLI via `mdcode::Cli` and calls `mdcode::run()`.
  - Selects a GH backend (CLI vs Stub) and passes it to the library adapter if we adopt the trait.

## 6) Updated Public API
- Preserve existing public function signatures exactly during the split.
- If adopting the GH backend trait, expose only a minimal adapter that library functions accept (optional in Phase 2 to reduce risk). Phase 1: keep current behavior, spawning runtime inside CLI paths, not in library code.

## 7) Coverage Measurement Updates
- Makefile:
  - Replace `coverage-llvm` command with: `cargo llvm-cov --lib --summary-only --json --output-path target/coverage/llvm-summary.json`.
  - Add `coverage-detailed` (developer aid): `cargo llvm-cov --lib --json --output-path target/coverage/llvm-detailed.json`.
- Gate thresholds in CI using `--lib` total lines; keep Python gate script but allow reading the new LLVM file semantics.

## 8) Test Plan (Revised)
- Stage A: Move existing tests to `tests/` with minimal edits:
  - Replace `use super::*;` with `use mdcode::*;` and add `use git2::Repository; use std::path::Path;` where needed.
  - Use `#[cfg(unix)]` for any `true`-based diff tool tests.
  - Ensure environment guards (e.g., `MDCODE_DIFF_TOOL`) are set/unset per test.
- Stage B: Add targeted tests only after parity is confirmed:
  - `diff_command(..)` invalid/mixed modes and timestamp error handling.
  - `launch_diff_tool(..)` failure and fallback branches.
  - `info_repository(..)` empty/one/≥20 commit list edges.
  - `is_dirty(..)` staged/typechange/rename and EOL-only path.
- Stage C: Keep GH tests fully offline (Stub backend or CLI presence simulation with temp PATH shims if needed).

## 9) Migration Steps (Revised)
1. Create `src/lib.rs` and move production code verbatim. Mark items `pub` per existing test usage; do not modify strings, logic, or enums.
2. Reduce `src/main.rs` to CLI + logging wrapper that calls into lib.
3. Move tests into `tests/` (straight copy of bodies), fix imports only; verify `cargo test` passes.
4. Update Makefile for `--lib` coverage; run coverage and validate metrics.
5. Add targeted tests; iterate until LLVM ≥98% and Tarpaulin ≥95%.
6. Optionally introduce `GhBackend` trait in a follow‑up if needed for further isolation; not required to hit 98%.

## 10) Risk Register (Updated)
- Behavior change during move → Mitigation: verbatim copy + full test pass before new tests.
- Build warnings (`cfg(tarpaulin)`) → Mitigation: add check‑cfg lints.
- Windows CI variance → Mitigation: guard Unix‑specific tests; keep EOL normalization.
- Coverage regressions from bin/tests inclusion → Mitigation: use `--lib` in cargo‑llvm‑cov invocations.
- Git operations timing/flakiness → Mitigation: use local bare remotes and deterministic flows as today.

## 11) Acceptance Criteria (Updated)
- `cargo test` green on Linux (and ideally Windows with platform‑guarded tests).
- `make coverage` green; LLVM report uses `--lib` and shows ≥98% line coverage; Tarpaulin ≥95%.
- CLI behavior unchanged (existing tests validate paths and messages).

## 12) Implementation Notes / Snippets
- Cargo.toml (lint config to recognize tarpaulin cfg):
  ```toml
  [lints.rust]
  unexpected_cfgs = { level = "warn", check-cfg = ["cfg(tarpaulin)"] }
  ```
- Makefile (LLVM lib‑only):
  ```make
  coverage-llvm:
	mkdir -p target/coverage
	cargo llvm-cov --lib --summary-only --json --output-path target/coverage/llvm-summary.json

  coverage-detailed:
	mkdir -p target/coverage
	cargo llvm-cov --lib --json --output-path target/coverage/llvm-detailed.json
  ```
- `gh_cli_path` without new deps (pseudo):
  ```rust
  fn gh_cli_path() -> Option<PathBuf> {
      let exe = if cfg!(windows) { "gh.exe" } else { "gh" };
      std::env::var_os("PATH")?.to_string_lossy()
          .split(if cfg!(windows) { ';' } else { ':' })
          .map(PathBuf::from)
          .flat_map(|p| std::fs::read_dir(p).ok().into_iter().flatten())
          .find_map(|e| {
              let p = e.ok()?.path();
              if p.file_name().map(|n| n == exe).unwrap_or(false) { Some(p) } else { None }
          })
  }
  ```

## 13) Timeline
- Day 1: Split + move tests with minimal changes; parity coverage validated.
- Day 2: Add targeted tests; set `--lib` gating; iterate to ≥98%.
- Day 3: CI threshold bump; docs polish; optional GH backend trait spike.

## 14) Decision Log
- Keep behavior identical during split (no functional changes).
- Avoid new dependencies; emulate `which` with std or feature‑gate later.
- Use `--lib` in llvm‑cov to focus on production lines.
- Post‑refactor optimizations (e.g., GH backend trait) deferred until after coverage target.

