# Design: Refactor to Library and Test Reorg for 98% Coverage

Date: 2025-10-30
Owner: md
Repo: mdcode (Rust crate/CLI)

## 1. Overview
This design proposes a focused refactor to separate production logic from the CLI binary, reorganize tests into integration suites, and add targeted tests to achieve ≥98% line coverage (LLVM) and ≥95% Tarpaulin coverage, while keeping the CLI behavior and UX unchanged.

The current code consolidates all logic and tests in `src/main.rs`. This conflation inflates LLVM’s coverage denominator (test lines are counted) and makes it harder to reason about public APIs and coverage gaps. The refactor introduces a `src/lib.rs` library that exposes the core functionality, keeps `src/main.rs` as a thin wrapper that delegates to the library, and moves tests to `tests/` so test sources do not impact library line coverage.

## 2. Goals
- Reach and maintain: LLVM lines ≥98%, Tarpaulin lines ≥95%.
- Keep CLI interface and behavior identical for all subcommands (`new`, `update`, `info`, `diff`, `gh_*`, `tag`).
- Isolate production logic to a `lib` crate surface that is testable and stable.
- Move tests to `tests/` (integration) or `lib.rs` unit tests where appropriate.
- Add targeted tests for uncovered branches (diff, info, dirty checks, GH flows, diff-tool paths).
- Preserve local/offline testability (no network; use temp Git repos and stubs).

## 3. Non‑Goals
- No change to user‑visible CLI flags, output text, or exit codes.
- No change to dependency stack beyond adding internal wiring if required.
- No switch to external coverage services; we keep `cargo llvm-cov` and `tarpaulin`.

## 4. Current State (Summary)
- Structure: single file `src/main.rs` with core functions and multiple `#[cfg(test)]` modules.
- Coverage (as measured 2025‑10‑30): Tarpaulin ~86%, LLVM ~90%. Test lines embedded in `main.rs` contribute to LLVM’s denominator, limiting progress to ≥98%.
- Uncovered hotspots include: `diff_command(..)` edge/error paths, `launch_diff_tool(..)` fallbacks, `info_repository(..)` list/empty/error paths, `is_dirty(..)` staged/typechange/EOL cases, and isolated branches around GH helpers.

## 5. Proposed Architecture
### 5.1 Layout
- `src/lib.rs` (new)
  - Public API (see §6) implementing all core functionality.
  - Encapsulates Git operations, diff ops, GitHub flows, and helpers.
- `src/main.rs`
  - Thin wrapper: parse CLI args and call `mdcode::run()`.
  - Contains no production logic beyond env_logger init and error printing.
- `tests/` (new integration suites)
  - `tests/tag.rs`, `tests/diff.rs`, `tests/gh.rs`, `tests/repo.rs`, `tests/detect.rs`.
  - Use `tempfile` and `git` CLI for isolated scenarios; never use network.

### 5.2 Module Boundaries (lib)
- `cli` (optional small submodule or inline in lib root): `Cli`, `Commands`, `execute_cli`, `run`.
- `repo`: `new_repository`, `update_repository`, `info_repository`, scan functions, file‑type detect, `.gitignore` helpers, `is_dirty`.
- `diff`: `diff_command`, `checkout_tree_to_dir`, temp dir helpers, diff tool launchers.
- `gh`: `gh_cli_path`, `gh_create_via_cli`, `gh_create_api` (stubbed offline), `add_remote`, `gh_push`, `gh_fetch`, `gh_sync`, `remote_branch_exists`.
- `tag`: `normalize_semver_tag`, `tag_release`, `read_version_from_cargo_toml`.

## 6. Public API Surface (lib)
- Entry
  - `pub fn run() -> Result<(), Box<dyn Error>>`
  - `pub fn execute_cli(cli: Cli) -> Result<(), Box<dyn Error>>`
  - `#[derive(Parser)] pub struct Cli` and `#[derive(Subcommand)] pub enum Commands`
- Repo
  - `pub fn new_repository(dir: &str, dry_run: bool, max_file_mb: u64) -> Result<(), Box<dyn Error>>`
  - `pub fn update_repository(dir: &str, dry_run: bool, commit_msg: Option<&str>, max_file_mb: u64) -> Result<(), Box<dyn Error>>`
  - `pub fn info_repository(dir: &str) -> Result<(), Box<dyn Error>>`
  - `pub fn scan_total_files(dir: &str) -> Result<usize, Box<dyn Error>>`
  - `pub fn scan_source_files(dir: &str, max_file_mb: u64) -> Result<(Vec<PathBuf>, usize), Box<dyn Error>>`
  - `pub fn detect_file_type(file_path: &Path) -> Option<&'static str>`
  - `pub fn create_gitignore(dir: &str, dry_run: bool) -> Result<(), Box<dyn Error>>`
  - `pub fn generate_gitignore_content(dir: &str) -> Result<String, Box<dyn Error>>`
  - `pub fn is_dirty(dir: &str) -> Result<bool, Box<dyn Error>>`
- Diff
  - `pub fn diff_command(dir: &str, versions: &[String], dry_run: bool) -> Result<(), Box<dyn Error>>`
  - `pub fn launch_diff_tool(before: &Path, after: &Path) -> Result<(), Box<dyn Error>>`
  - `pub fn launch_custom_diff_tool(tool: &OsStr, before: &Path, after: &Path) -> Result<bool, Box<dyn Error>>`
  - `pub fn checkout_tree_to_dir(repo: &Repository, tree: &git2::Tree<'_>, out_dir: &Path) -> Result<(), Box<dyn Error>>`
  - `pub fn create_temp_dir(prefix: &str) -> Result<PathBuf, Box<dyn Error>>`
- GitHub
  - `pub fn gh_cli_path() -> Option<PathBuf>`
  - `pub fn gh_create_via_cli(gh_cmd: &Path, directory: &str, repo_name: &str, description: Option<String>, visibility: RepoVisibility) -> Result<(), Box<dyn Error>>`
  - `pub async fn gh_create_api(repo_name: &str, description: Option<&str>, visibility: RepoVisibility) -> Result<String, Box<dyn Error>>` (offline stub)
  - `pub fn add_remote(directory: &str, remote_name: &str, remote_url: &str) -> Result<(), Box<dyn Error>>`
  - `pub fn gh_push(directory: &str, remote: &str) -> Result<(), Box<dyn Error>>`
  - `pub fn gh_fetch(directory: &str, remote: &str) -> Result<(), Box<dyn Error>>`
  - `pub fn gh_sync(directory: &str, remote: &str) -> Result<(), Box<dyn Error>>`
  - `pub fn remote_branch_exists(directory: &str, remote: &str, branch: &str) -> Result<bool, Box<dyn Error>>`
- Tagging
  - `pub fn normalize_semver_tag(input: &str) -> Result<(SemverVersion, String), Box<dyn Error>>`
  - `pub fn read_version_from_cargo_toml(dir: &str) -> Result<Option<String>, Box<dyn Error>>`
  - `pub fn tag_release(directory: &str, version: Option<String>, message: Option<String>, push: bool, remote: &str, force: bool, allow_dirty: bool, dry_run: bool) -> Result<(), Box<dyn Error>>`
- Types
  - `#[derive(Clone, Copy)] pub enum RepoVisibility { Public, Private, Internal }`

Notes:
- Keep signatures backward‑compatible with existing tests.
- For `gh_create_api`, maintain a stub that returns a temp bare repo path; no network.

## 7. CLI Binary (`src/main.rs`)
- Initialize `env_logger` with the same formatting (error prefix, info default).
- Call `mdcode::run()`, print formatted error on failure, preserve `#[cfg(tarpaulin)] fn main(){}` to make Tarpaulin happy if desired.

## 8. Test Strategy
### 8.1 Reorganization
- Extract all inline tests from `src/main.rs` into `tests/` files:
  - `tests/tag.rs`: semver normalization, tag creation/dry‑run, allow‑dirty enforcement, version from Cargo.toml, pushing tag to remote.
  - `tests/repo.rs`: new repo creation, update (dry‑run and real), `.gitignore` generation, `is_dirty` EOL/whitespace only, staged‑only changes.
  - `tests/diff.rs`: invalid indices, H/L modes, dry‑run prep, real launch with `MDCODE_DIFF_TOOL=true`, fallback messaging when `git difftool` missing.
  - `tests/gh.rs`: `gh_cli_path` presence/absence, CLI vs API fallback, add remote idempotency, push errors (detached HEAD), fetch/sync when remote branch missing.
  - `tests/detect.rs`: file‑type mappings including special names (`Dockerfile`, `CMakeLists.txt`, lockfiles) and additional asset types.

### 8.2 Targeted Coverage Gaps (new tests)
- `diff_command(..)`
  - bad index parse, index out of range, mixed modes length mismatch, timestamp parse error injection (invalid commit time via stub), dry‑run summary.
- `launch_diff_tool(..)`
  - env override success (`true` on Unix), CLI failure path, absence fallback printing, Windows branch guarded if CI supports.
- `info_repository(..)`
  - empty repo error, single commit, ≥20 commits listing (iterate loop branches).
- `is_dirty(..)`
  - staged new/deleted/typechange returns dirty; CRLF→LF normalization unchanged path returns clean; renamed/not‑in‑HEAD considered dirty.
- Minor edges
  - `read_version_from_cargo_toml` missing `[package]` or `version`.
  - `gh_cli_path` PATH probe.
  - `remote_branch_exists` both success and failure code paths.

### 8.3 Isolation & Determinism
- Use `tempfile::tempdir` and `git` CLI with local bare remotes.
- NEVER use network. Disable automatic pushes unless explicitly part of scenario.
- Use guards for environment variables (e.g., set/unset `MDCODE_DIFF_TOOL`).

## 9. Coverage & Tooling
- Keep `Makefile` targets:
  - `coverage-tarpaulin`: `cargo tarpaulin --out Json --output-dir target/coverage`.
  - `coverage-llvm`: `cargo llvm-cov --summary-only --json --output-path target/coverage/llvm-summary.json`.
  - `coverage`: both, then run `scripts/coverage_gate.py`.
- Add developer helper `coverage-detailed` (optional): `cargo llvm-cov --json --output-path target/coverage/llvm-detailed.json`.
- Gate in CI using either:
  - `coverage_gate.py` (baseline ± drop) and/or
  - `cargo llvm-cov --fail-under-lines=98` once thresholds are met locally.

## 10. Migration Plan
1) Create `src/lib.rs`; copy production functions from `src/main.rs` without modification; expose as `pub` per §6.
2) Replace `src/main.rs` with thin wrapper calling `mdcode::run()` from lib.
3) Move tests into `tests/`, fix imports to `use mdcode::*;` and add any necessary `use git2::Repository; use std::path::Path;` inside each module.
4) Run `cargo test`, `make coverage`, iterate on compilation issues, preserve functionality.
5) Add new targeted tests per §8.2, incrementally watching coverage rise; fix only coverage‑related gaps, avoid behavior change.
6) Once ≥98% LLVM is reached locally, tighten CI thresholds.

## 11. Risks & Mitigations
- API drift when moving functions to lib
  - Mitigation: copy signatures verbatim; run existing tests after migration before adding new ones.
- Test flakiness with Git processes
  - Mitigation: consistent author/committer config in tests; avoid timing sensitivities; use local bare remotes.
- Platform‑specific diff tooling
  - Mitigation: use `MDCODE_DIFF_TOOL=true` for success path; cover `git difftool` absence via fallback printing.
- Tarpaulin and LLVM discrepancies
  - Mitigation: validate with both tools; prioritize LLVM ≥98% while keeping Tarpaulin ≥95%.

## 12. Rollback Plan
- If the split causes instability, revert to monolithic `src/main.rs` and inline tests (current HEAD). No data migrations required.

## 13. Acceptance Criteria
- `cargo test` passes locally (Linux) with the same scenarios as before.
- `make coverage` succeeds; artifacts written to `target/coverage/`.
- LLVM line coverage ≥98%; Tarpaulin line coverage ≥95%.
- CLI commands behave identically, evidenced by existing integration tests.

## 14. Timeline (Aggressive)
- Day 1: lib/bin split + compile; move tests to `tests/`; reach parity (coverage may dip temporarily).
- Day 2: add targeted tests; close gaps; validate ≥98% LLVM locally.
- Day 3: tighten CI thresholds; documentation pass and cleanup.

## 15. Open Questions
- Do we want branch or mcdc coverage (unstable in cargo‑llvm‑cov)? Not required for this goal.
- Should `gh_create_api` evolve beyond a no‑network stub behind a feature gate? For now, keep stubbed offline.

## 16. Appendix A — File Mapping
- From `src/main.rs` (production logic) → `src/lib.rs` modules:
  - CLI types and `execute_cli`/`run` → lib root.
  - Repo helpers (`new_repository`, `update_repository`, `is_dirty`, scans, `.gitignore`) → repo module.
  - Diff helpers (`diff_command`, temp dir, checkout, launchers) → diff module.
  - GH helpers (`gh_*`, `remote_branch_exists`) → gh module.
  - Tagging (`normalize_semver_tag`, `tag_release`, `read_version_from_cargo_toml`) → tag module.

## 17. Appendix B — Test Matrix (Examples)
- `diff_command` modes: `[]`, `["0"]`, `["1"]`, `["H","0"]`, `["L"]`, bad: `["H"]`, `["x"]`, `["0","x"]`.
- `launch_diff_tool`: env present success, env present failure, `git difftool` missing, success.
- `info_repository`: error (not a repo), empty repo, 1 commit, 20+ commits cap.
- `is_dirty`: staged new/deleted/typechange, content diff vs EOL‑only, path not in HEAD.
- `gh_push`: detached HEAD error, remote branch exists vs not, pull failure path, push with `-u`.
- `tag_release`: with/without version flag, force overwrite guard, allow‑dirty guard, dry‑run push log.

